<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>rsync(1) - Linux man page</title>
<!-- base href="http://linux.die.net/man/1/rsync" -->
<link rel="canonical" href="http://linux.die.net/man/1/rsync">
<link rel="stylesheet" type="text/css" href="rsync%281%29%20-%20Linux%20man%20page_files/white.css">
<link rel="shortcut icon" href="http://linux.die.net/favicon.ico" type="image/x-icon">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="description" content="Rsync is a fast and extraordinarily versatile file copying tool. It can copy locally, to/from another host over any remote shell, or to/from a remote rsync ...">
<script src="rsync%281%29%20-%20Linux%20man%20page_files/ca-pub-5823754184406795.js" type="text/javascript" async=""></script><script src="rsync%281%29%20-%20Linux%20man%20page_files/ga.js" async="" type="text/javascript"></script><script type="text/javascript">
<!--
var _gaq = _gaq || [];_gaq.push(['_setAccount', 'UA-50820-6']);_gaq.push(['_trackPageview']);
window.google_analytics_uacct = 'UA-50820-6';
// -->
</script>
</head>

<body>
<div id="bg">
<div id="logo">
<a href="http://www.die.net/"><img src="rsync%281%29%20-%20Linux%20man%20page_files/logo.svg" alt="die.net" onerror="this.onerror=null; this.src='/style/logo.png'" height="120" width="120"></a>
</div>
<div id="content">

<!-- google_ad_section_start -->
<h1>rsync(1) - Linux man page</h1>

<h2>Name</h2>
rsync -- a fast, versatile, remote (and local) file-copying tool
<h2>Synopsis</h2>
<pre class="code">Local:  rsync [OPTION...] SRC... [DEST]
Access via remote shell:
  Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]
  Push: rsync [OPTION...] SRC... [USER@]HOST:DEST
Access via rsync daemon:
  Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]
        rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
  Push: rsync [OPTION...] SRC... [USER@]HOST::DEST
        rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST</pre>Usages with just one SRC arg and no DEST arg will list the source files instead of copying.
<h2>Description</h2>
<div id="adright">
<script async="" src="rsync%281%29%20-%20Linux%20man%20page_files/adsbygoogle.js"></script>
<ins data-adsbygoogle-status="done" class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-5823754184406795" data-ad-slot="7130739364"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent"><ins id="aswift_0_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;" frameborder="0" height="280" width="336"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<p>Rsync is a fast and extraordinarily versatile file copying tool. It 
can copy locally, to/from another host over any remote shell, or to/from
 a remote rsync
daemon. It offers a large number of options that control every aspect of
 its behavior and permit very flexible specification of the set of files
 to be copied.
It is famous for its delta-transfer algorithm, which reduces the amount 
of data sent over the network by sending only the differences between 
the source files
and the existing files in the destination. Rsync is widely used for 
backups and mirroring and as an improved copy command for everyday use.
</p><p>Rsync finds files that need to be transferred using a lqquick 
checkrq algorithm (by default) that looks for files that have changed in
 size or in
last-modified time. Any changes in the other preserved attributes (as 
requested by options) are made on the destination file directly when the
 quick check
indicates that the file's data does not need to be updated.
</p><p>Some of the additional features of rsync are:
</p><dl compact="compact">
<dt>o
</dt><dd>support for copying links, devices, owners, groups, and permissions
</dd><dt>o
</dt><dd>exclude and exclude-from options similar to GNU tar
</dd><dt>o
</dt><dd>a CVS exclude mode for ignoring the same files that CVS would ignore
</dd><dt>o
</dt><dd>can use any transparent remote shell, including ssh or rsh
</dd><dt>o
</dt><dd>does not require super-user privileges
</dd><dt>o
</dt><dd>pipelining of file transfers to minimize latency costs
</dd><dt>o
</dt><dd>support for anonymous or authenticated rsync daemons (ideal for mirroring)</dd></dl>
<h2>General</h2>
<p>Rsync copies files either to or from a remote host, or locally on the
 current host (it does not support copying files between two remote 
hosts).
</p><p>There are two different ways for rsync to contact a remote 
system: using a remote-shell program as the transport (such as ssh or 
rsh) or contacting an rsync
daemon directly via TCP. The remote-shell transport is used whenever the
 source or destination path contains a single colon (:) separator after a
 host
specification. Contacting an rsync daemon directly happens when the 
source or destination path contains a double colon (::) separator after a
 host
specification, OR when an rsync:// URL is specified (see also the 
lqUSING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTIONrq section 
for an exception to
this latter rule).
</p><p>As a special case, if a single source arg is specified without a 
destination, the files are listed in an output format similar to lqls 
-lrq.
</p><p>As expected, if neither the source or destination path specify a remote host, the copy occurs locally (see also the <b>--list-only</b> option).
</p><p>Rsync refers to the local side as the lqclientrq and the remote 
side as the lqserverrq. Don't confuse lqserverrq with an rsync daemon --
 a daemon is always
a server, but a server can be either a daemon or a remote-shell spawned 
process.
</p><h2>Setup</h2>
<p>See the file README for installation instructions.
</p><p>Once installed, you can use rsync to any machine that you can 
access via a remote shell (as well as some that you can access using the
 rsync daemon-mode
protocol). For remote transfers, a modern rsync uses ssh for its 
communications, but it may have been configured to use a different 
remote shell by default,
such as rsh or remsh.
</p><p>You can also specify any remote shell you like, either by using the <b>-e</b> command line option, or by setting the RSYNC_RSH environment variable.
</p><p>Note that rsync must be installed on both the source and destination machines.
</p><h2>Usage</h2>
<p>You use rsync in the same way you use rcp. You must specify a source and a destination, one of which may be remote.
</p><p>Perhaps the best way to explain the syntax is with some examples:
</p><blockquote>CWrsync -t *.c foo:src/</blockquote>
<p>This would transfer all files matching the pattern *.c from the 
current directory to the directory src on the machine foo. If any of the
 files already exist
on the remote system then the rsync remote-update protocol is used to 
update the file by sending only the differences. See the tech report for
 details.
</p><blockquote>CWrsync -avz foo:src/bar /data/tmp</blockquote>
<p>This would recursively transfer all files from the directory src/bar 
on the machine foo into the /data/tmp/bar directory on the local 
machine. The files are
transferred in lqarchiverq mode, which ensures that symbolic links, 
devices, attributes, permissions, ownerships, etc. are preserved in the 
transfer.
Additionally, compression will be used to reduce the size of data 
portions of the transfer.
</p><blockquote>CWrsync -avz foo:src/bar/ /data/tmp</blockquote>
<p>A trailing slash on the source changes this behavior to avoid 
creating an additional directory level at the destination. You can think
 of a trailing / on a
source as meaning lqcopy the contents of this directoryrq as opposed to 
lqcopy the directory by namerq, but in both cases the attributes of the 
containing
directory are transferred to the containing directory on the 
destination. In other words, each of the following commands copies the 
files in the same way,
including their setting of the attributes of /dest/foo:
</p><blockquote>CWrsync -av /src/foo /dest<br>
CWrsync -av /src/foo/ /dest/foo<br></blockquote>
<p>Note also that host and module references don't require a trailing 
slash to copy the contents of the default directory. For example, both 
of these copy the
remote directory's contents into lq/destrq:
</p><blockquote>CWrsync -av host: /dest<br>
CWrsync -av host::module /dest<br></blockquote>
<p>You can also use rsync in local-only mode, where both the source and 
destination don't have a oq:cq in the name. In this case it behaves like
 an improved
copy command.
</p><p>Finally, you can list all the (listable) modules available from a particular rsync daemon by leaving off the module name:
</p><blockquote>CWrsync somehost.mydomain.com::</blockquote>
<p>See the following section for more details.
</p><h2>Advanced Usage</h2>
<p>The syntax for requesting multiple files from a remote host is done 
by specifying additional remote-host args in the same style as the 
first, or with the
hostname omitted. For instance, all these work:
</p><blockquote>CWrsync -av host:file1 :file2 host:file{3,4} /dest/<br>
CWrsync -av host::modname/file{1,2} host::modname/file3 /dest/<br>
CWrsync -av host::modname/file1 ::modname/file{3,4}</blockquote>
<p>Older versions of rsync required using quoted spaces in the SRC, like these examples:
</p><blockquote>CWrsync -av host:'dir1/file1 dir2/file2' /dest<br>
CWrsync host::'modname/dir1/file1 modname/dir2/file2' /dest</blockquote>
<p>This word-splitting still works (by default) in the latest rsync, but is not as easy to use as the first method.
</p><p>If you need to transfer a filename that contains whitespace, you can either specify the <b>--protect-args</b> (<b>-s</b>) option, or you'll need to escape
the whitespace in a way that the remote shell will understand. For instance:
</p><blockquote>CWrsync -av host:'file\ name\ with\ spaces' /dest</blockquote>
<h2>Connecting to an Rsync Daemon</h2>
<p>It is also possible to use rsync without a remote shell as the 
transport. In this case you will directly connect to a remote rsync 
daemon, typically using
TCP port 873. (This obviously requires the daemon to be running on the 
remote system, so refer to the STARTING AN RSYNC DAEMON TO ACCEPT 
CONNECTIONS section
below for information on that.)
</p><p>Using rsync in this way is the same as using it with a remote shell except that:
</p><dl compact="compact">
<dt>o
</dt><dd>you either use a double colon :: instead of a single colon to separate the hostname from the path, or you use an rsync:// URL.
</dd><dt>o
</dt><dd>the first word of the lqpathrq is actually a module name.
</dd><dt>o
</dt><dd>the remote daemon may print a message of the day when you connect.
</dd><dt>o
</dt><dd>if you specify no path name on the remote daemon then the list of accessible paths on the daemon will be shown.
</dd><dt>o
</dt><dd>if you specify no local destination then a listing of the specified files on the remote daemon is provided.
</dd><dt>o
</dt><dd>you must not specify the <b>--rsh</b> (<b>-e</b>) option.</dd></dl>
<p>An example that copies all the files in a remote module named lqsrcrq:
</p><pre class="code">rsync -av host::src /dest</pre>Some modules on the
 remote daemon may require authentication. If so, you will receive a 
password prompt when you connect. You can avoid the password prompt
by setting the environment variable RSYNC_PASSWORD to the password you 
want to use or using the <b>--password-file</b> option. This may be useful when
scripting rsync.
<p>WARNING: On some systems environment variables are visible to all users. On those systems using <b>--password-file</b> is recommended.
</p><p>You may establish the connection via a web proxy by setting the 
environment variable RSYNC_PROXY to a hostname:port pair pointing to 
your web proxy. Note
that your web proxy's configuration must support proxy connections to 
port 873.
</p><p>You may also establish a daemon connection using a program as a 
proxy by setting the environment variable RSYNC_CONNECT_PROG to the 
commands you wish to run
in place of making a direct socket connection. The string may contain 
the escape lq%Hrq to represent the hostname specified in the rsync 
command (so use lq%%rq
if you need a single lq%rq in your string). For example:
</p><pre class="code">export RSYNC_CONNECT_PROG='ssh proxyhost nc %H 873'
rsync -av targethost1::module/src/ /dest/
rsync -av rsync:://targethost2/module/src/ /dest/</pre>The command 
specified above uses ssh to run nc (netcat) on a proxyhost, which 
forwards all data to port 873 (the rsync daemon) on the targethost (%H).
<h2>Using Rsync-daemon Features Via a Remote-shell Connection</h2>
<p>It is sometimes useful to use various features of an rsync daemon 
(such as named modules) without actually allowing any new socket 
connections into a system
(other than what is already required to allow remote-shell access). 
Rsync supports connecting to a host using a remote shell and then 
spawning a single-use
lqdaemonrq server that expects to read its config file in the home dir 
of the remote user. This can be useful if you want to encrypt a 
daemon-style transfer's
data, but since the daemon is started up fresh by the remote user, you 
may not be able to use features such as chroot or change the uid used by
 the daemon.
(For another way to encrypt a daemon transfer, consider using ssh to 
tunnel a local port to a remote machine and configure a normal rsync 
daemon on that remote
host to only allow connections from lqlocalhostrq.)
</p><p>From the user's perspective, a daemon transfer via a remote-shell
 connection uses nearly the same command-line syntax as a normal 
rsync-daemon transfer,
with the only exception being that you must explicitly set the remote 
shell program on the command-line with the <b>--rsh=COMMAND</b> option. (Setting the
RSYNC_RSH in the environment will not turn on this functionality.) For example:
</p><pre class="code">rsync -av --rsh=ssh host::module /dest</pre>If you
 need to specify a different remote-shell user, keep in mind that the 
user@ prefix in front of the host is specifying the rsync-user value 
(for a
module that requires user-based authentication). This means that you 
must give the '-l user' option to ssh when specifying the remote-shell, 
as in this example
that uses the short version of the <b>--rsh</b> option:
<pre class="code">rsync -av -e "ssh -l ssh-user" rsync-user@host::module /dest</pre>The lqssh-userrq will be used at the ssh level; the lqrsync-userrq will be used to log-in to the lqmodulerq.
<h2>Starting an Rsync Daemon to Accept Connections</h2>
<p>In order to connect to an rsync daemon, the remote system needs to 
have a daemon already running (or it needs to have configured something 
like inetd to
spawn an rsync daemon for incoming connections on a particular port). 
For full information on how to start a daemon that will handling 
incoming socket
connections, see the <i><b><a href="http://linux.die.net/man/5/rsyncd.conf">rsyncd.conf</a></b>(5)</i> man page -- that is the config file for the daemon, and it contains the full details for how to run the
daemon (including stand-alone and inetd configurations).
</p><p>If you're using one of the remote-shell transports for the transfer, there is no need to manually start an rsync daemon.
</p><h2>Examples</h2>
<p>Here are some examples of how I use rsync.
</p><p>To backup my wife's home directory, which consists of large MS Word files and mail folders, I use a cron job that runs
</p><blockquote>CWrsync -Cavz . arvidsjaur:backup</blockquote>
<p>each night over a PPP connection to a duplicate directory on my machine lqarvidsjaurrq.
</p><p>To synchronize my samba source trees I use the following Makefile targets:
</p><pre class="code">get:
        rsync -avuzb --exclude '*~' samba:samba/ .
put:
        rsync -Cavuzb . samba:samba/
sync: get put</pre>this allows me to sync with a CVS directory at the 
other end of the connection. I then do CVS operations on the remote 
machine, which saves a lot of time as
the remote CVS protocol isn't very efficient.
<p>I mirror a directory between my lqoldrq and lqnewrq ftp sites with the command:
</p><p>CWrsync -az -e ssh --delete ~ftp/pub/samba nimbus:"~ftp/pub/tridge"
</p><p>This is launched from cron every few hours.
</p><h2>Options Summary</h2>
<p>Here is a short summary of the options available in rsync. Please 
refer to the detailed description below for a complete description.</p><pre class="code"> -v, --verbose               increase verbosity
 -q, --quiet                 suppress non-error messages
     --no-motd               suppress daemon-mode MOTD (see caveat)
 -c, --checksum              skip based on checksum, not mod-time &amp; size
 -a, --archive               archive mode; equals -rlptgoD (no -H,-A,-X)
     --no-OPTION             turn off an implied OPTION (e.g. --no-D)
 -r, --recursive             recurse into directories
 -R, --relative              use relative path names
     --no-implied-dirs       don't send implied dirs with --relative
 -b, --backup                make backups (see --suffix &amp; --backup-dir)
     --backup-dir=DIR        make backups into hierarchy based in DIR
     --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
 -u, --update                skip files that are newer on the receiver
     --inplace               update destination files in-place
     --append                append data onto shorter files
     --append-verify         --append w/old data in file checksum
 -d, --dirs                  transfer directories without recursing
 -l, --links                 copy symlinks as symlinks
 -L, --copy-links            transform symlink into referent file/dir
     --copy-unsafe-links     only "unsafe" symlinks are transformed
     --safe-links            ignore symlinks that point outside the tree
 -k, --copy-dirlinks         transform symlink to dir into referent dir
 -K, --keep-dirlinks         treat symlinked dir on receiver as dir
 -H, --hard-links            preserve hard links
 -p, --perms                 preserve permissions
 -E, --executability         preserve executability
     --chmod=CHMOD           affect file and/or directory permissions
 -A, --acls                  preserve ACLs (implies -p)
 -X, --xattrs                preserve extended attributes
 -o, --owner                 preserve owner (super-user only)
 -g, --group                 preserve group
     --devices               preserve device files (super-user only)
     --specials              preserve special files
 -D                          same as --devices --specials
 -t, --times                 preserve modification times
 -O, --omit-dir-times        omit directories from --times
     --super                 receiver attempts super-user activities
     --fake-super            store/recover privileged attrs using xattrs
 -S, --sparse                handle sparse files efficiently
 -n, --dry-run               perform a trial run with no changes made
 -W, --whole-file            copy files whole (w/o delta-xfer algorithm)
 -x, --one-file-system       don't cross filesystem boundaries
 -B, --block-size=SIZE       force a fixed checksum block-size
 -e, --rsh=COMMAND           specify the remote shell to use
     --rsync-path=PROGRAM    specify the rsync to run on remote machine
     --existing              skip creating new files on receiver
     --ignore-existing       skip updating files that exist on receiver
     --remove-source-files   sender removes synchronized files (non-dir)
     --del                   an alias for --delete-during
     --delete                delete extraneous files from dest dirs
     --delete-before         receiver deletes before transfer (default)
     --delete-during         receiver deletes during xfer, not before
     --delete-delay          find deletions during, delete after
     --delete-after          receiver deletes after transfer, not before
     --delete-excluded       also delete excluded files from dest dirs
     --ignore-errors         delete even if there are I/O errors
     --force                 force deletion of dirs even if not empty
     --max-delete=NUM        don't delete more than NUM files
     --max-size=SIZE         don't transfer any file larger than SIZE
     --min-size=SIZE         don't transfer any file smaller than SIZE
     --partial               keep partially transferred files
     --partial-dir=DIR       put a partially transferred file into DIR
     --delay-updates         put all updated files into place at end
 -m, --prune-empty-dirs      prune empty directory chains from file-list
     --numeric-ids           don't map uid/gid values by user/group name
     --timeout=SECONDS       set I/O timeout in seconds
     --contimeout=SECONDS    set daemon connection timeout in seconds
 -I, --ignore-times          don't skip files that match size and time
     --size-only             skip files that match in size
     --modify-window=NUM     compare mod-times with reduced accuracy
 -T, --temp-dir=DIR          create temporary files in directory DIR
 -y, --fuzzy                 find similar file for basis if no dest file
     --compare-dest=DIR      also compare received files relative to DIR
     --copy-dest=DIR         ... and include copies of unchanged files
     --link-dest=DIR         hardlink to files in DIR when unchanged
 -z, --compress              compress file data during the transfer
     --compress-level=NUM    explicitly set compression level
     --skip-compress=LIST    skip compressing files with suffix in LIST
 -C, --cvs-exclude           auto-ignore files in the same way CVS does
 -f, --filter=RULE           add a file-filtering RULE
 -F                          same as --filter='dir-merge /.rsync-filter'
                             repeated: --filter='- .rsync-filter'
     --exclude=PATTERN       exclude files matching PATTERN
     --exclude-from=FILE     read exclude patterns from FILE
     --include=PATTERN       don't exclude files matching PATTERN
     --include-from=FILE     read include patterns from FILE
     --files-from=FILE       read list of source-file names from FILE
 -0, --from0                 all *from/filter files are delimited by 0s
 -s, --protect-args          no space-splitting; wildcard chars only
     --address=ADDRESS       bind address for outgoing socket to daemon
     --port=PORT             specify double-colon alternate port number
     --sockopts=OPTIONS      specify custom TCP options
     --blocking-io           use blocking I/O for the remote shell
     --stats                 give some file-transfer stats
 -8, --8-bit-output          leave high-bit chars unescaped in output
 -h, --human-readable        output numbers in a human-readable format
     --progress              show progress during transfer
 -P                          same as --partial --progress
 -i, --itemize-changes       output a change-summary for all updates
     --out-format=FORMAT     output updates using the specified FORMAT
     --log-file=FILE         log what we're doing to the specified FILE
     --log-file-format=FMT   log updates using the specified FMT
     --password-file=FILE    read daemon-access password from FILE
     --list-only             list the files instead of copying them
     --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
     --write-batch=FILE      write a batched update to FILE
     --only-write-batch=FILE like --write-batch but w/o updating dest
     --read-batch=FILE       read a batched update from FILE
     --protocol=NUM          force an older protocol version to be used
     --iconv=CONVERT_SPEC    request charset conversion of filenames
     --checksum-seed=NUM     set block/file checksum seed (advanced)
 -4, --ipv4                  prefer IPv4
 -6, --ipv6                  prefer IPv6
     --version               print version number
(-h) --help                  show this help (see below for -h comment)</pre>Rsync can also be run as a daemon, in which case the following options are accepted:<pre class="code">    --daemon                run as an rsync daemon
    --address=ADDRESS       bind to the specified address
    --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
    --config=FILE           specify alternate rsyncd.conf file
    --no-detach             do not detach from the parent
    --port=PORT             listen on alternate port number
    --log-file=FILE         override the "log file" setting
    --log-file-format=FMT   override the "log format" setting
    --sockopts=OPTIONS      specify custom TCP options
-v, --verbose               increase verbosity
-4, --ipv4                  prefer IPv4
-6, --ipv6                  prefer IPv6
-h, --help                  show this help (if used after --daemon)</pre>
<h2>Options</h2>
<p>rsync uses the GNU long options package. Many of the command line 
options have two variants, one short and one long. These are shown 
below, separated by
commas. Some options only have a long variant. The oq=cq for options 
that take a parameter is optional; whitespace can be used instead.
</p><dl compact="compact">
<dt><b>--help</b>
</dt><dd>Print a short help page describing the options available in 
rsync and exit. For backward-compatibility with older versions of rsync,
 the help will also be
output if you use the <b>-h</b> option without any other args.
</dd><dt><b>--version</b>
</dt><dd>print the rsync version number and exit.
</dd><dt><b>-v, --verbose</b>
</dt><dd>This option increases the amount of information you are given during the transfer. By default, rsync works silently. A single <b>-v</b> will give you
information about what files are being transferred and a brief summary at the end. Two <b>-v</b> options will give you information on what files are being
skipped and slightly more information at the end. More than two <b>-v</b> options should only be used if you are debugging rsync.
</dd><dt>Note that the names of the transferred files that are output are done using
</dt><dd>a default <b>--out-format</b> of lq%n%Lrq, which tells you just the name of the file and, if the item is a link, where it points. At the single <b>-v</b>
level of verbosity, this does not mention when a file gets its 
attributes changed. If you ask for an itemized list of changed 
attributes (either
<b>--itemize-changes</b> or adding lq%irq to the <b>--out-format</b> setting), the output (on the client) increases to mention all items that are changed in
any way. See the <b>--out-format</b> option for more details.
</dd><dt><b>-q, --quiet</b>
</dt><dd>This option decreases the amount of information you are given 
during the transfer, notably suppressing information messages from the 
remote server. This
option is useful when invoking rsync from cron.
</dd><dt><b>--no-motd</b>
</dt><dd>This option affects the information that is output by the 
client at the start of a daemon transfer. This suppresses the 
message-of-the-day (MOTD) text, but
it also affects the list of modules that the daemon sends in response to
 the lqrsync host::rq request (due to a limitation in the rsync 
protocol), so omit this
option if you want to request the list of modules from the daemon.
</dd><dt><b>-I, --ignore-times</b>
</dt><dd>Normally rsync will skip any files that are already the same 
size and have the same modification timestamp. This option turns off 
this lqquick checkrq
behavior, causing all files to be updated.
</dd><dt><b>--size-only</b>
</dt><dd>This modifies rsync's lqquick checkrq algorithm for finding 
files that need to be transferred, changing it from the default of 
transferring files with
either a changed size or a changed last-modified time to just looking 
for files that have changed in size. This is useful when starting to use
 rsync after
using another mirroring system which may not preserve timestamps 
exactly.
</dd><dt><b>--modify-window</b>
</dt><dd>When comparing two timestamps, rsync treats the timestamps as 
being equal if they differ by no more than the modify-window value. This
 is normally 0 (for
an exact match), but you may find it useful to set this to a larger 
value in some situations. In particular, when transferring to or from an
 MS Windows FAT
filesystem (which represents times with a 2-second resolution), <b>--modify-window=1</b> is useful (allowing times to differ by up to 1 second).
</dd><dt><b>-c, --checksum</b>
</dt><dd>This changes the way rsync checks if the files have been 
changed and are in need of a transfer. Without this option, rsync uses a
 lqquick checkrq that (by
default) checks if each file's size and time of last modification match 
between the sender and receiver. This option changes this to compare a 
128-bit checksum
for each file that has a matching size. Generating the checksums means 
that both sides will expend a lot of disk I/O reading all the data in 
the files in the
transfer (and this is prior to any reading that will be done to transfer
 changed files), so this can slow things down significantly.
</dd><dt>The sending side generates its checksums while it is doing the file-system
</dt><dd>scan that builds the list of the available files. The receiver 
generates its checksums when it is scanning for changed files, and will 
checksum any file
that has the same size as the corresponding sender's file: files with 
either a changed size or a changed checksum are selected for transfer.
</dd><dt>Note that rsync always verifies that each <i>transferred</i> file was
</dt><dd>correctly reconstructed on the receiving side by checking a 
whole-file checksum that is generated as the file is transferred, but 
that automatic
after-the-transfer verification has nothing to do with this option's 
before-the-transfer lqDoes this file need to be updated?rq check.
</dd><dt>For protocol 30 and beyond (first supported in 3.0.0), the checksum used is
</dt><dd>MD5. For older protocols, the checksum used is MD4.
</dd><dt><b>-a, --archive</b>
</dt><dd>This is equivalent to <b>-rlptgoD</b>. It is a quick way of saying you want recursion and want to preserve almost everything (with -H being a notable
omission). The only exception to the above equivalence is when <b>--files-from</b> is specified, in which case <b>-r</b> is not implied.
</dd><dt>Note that <b>-a does not preserve hardlinks</b>, because
</dt><dd>finding multiply-linked files is expensive. You must separately specify <b>-H</b>.
</dd><dt>--no-OPTION
</dt><dd>You may turn off one or more implied options by prefixing the 
option name with lqno-rq. Not all options may be prefixed with a 
lqno-rq: only options that
are implied by other options (e.g. <b>--no-D</b>, <b>--no-perms</b>) or have different defaults in various circumstances (e.g. <b>--no-whole-file</b>,
<b>--no-blocking-io</b>, <b>--no-dirs</b>). You may specify either the short or the long option name after the lqno-rq prefix (e.g. <b>--no-R</b> is the same
as <b>--no-relative</b>).
</dd><dt>For example: if you want to use <b>-a</b> (<b>--archive</b>) but don't want
</dt><dd><b>-o</b> (<b>--owner</b>), instead of converting <b>-a</b> into <b>-rlptgD</b>, you could specify <b>-a --no-o</b> (or <b>-a --no-owner</b>).
</dd><dt>The order of the options is important: if you specify <b>--no-r -a</b>, the
</dt><dd><b>-r</b> option would end up being turned on, the opposite of <b>-a --no-r</b>. Note also that the side-effects of the <b>--files-from</b> option are NOT
positional, as it affects the default state of several options and slightly changes the meaning of <b>-a</b> (see the <b>--files-from</b> option for more
details).
</dd><dt><b>-r, --recursive</b>
</dt><dd>This tells rsync to copy directories recursively. See also <b>--dirs</b> (<b>-d</b>).
</dd><dt>Beginning with rsync 3.0.0, the recursive algorithm used is now an
</dt><dd>incremental scan that uses much less memory than before and 
begins the transfer after the scanning of the first few directories have
 been completed. This
incremental scan only affects our recursion algorithm, and does not 
change a non-recursive transfer. It is also only possible when both ends
 of the transfer
are at least version 3.0.0.
</dd><dt>Some options require rsync to know the full file list, so these options
</dt><dd>disable the incremental recursion mode. These include: <b>--delete-before</b>, <b>--delete-after</b>, <b>--prune-empty-dirs</b>, and
<b>--delay-updates</b>. Because of this, the default delete mode when you specify <b>--delete</b> is now <b>--delete-during</b> when both ends of the
connection are at least 3.0.0 (use <b>--del</b> or <b>--delete-during</b> to request this improved deletion mode explicitly). See also the
<b>--delete-delay</b> option that is a better choice than using <b>--delete-after</b>.
</dd><dt>Incremental recursion can be disabled using the <b>--no-inc-recursive</b>
</dt><dd>option or its shorter <b>--no-i-r</b> alias.
</dd><dt><b>-R, --relative</b>
</dt><dd>Use relative paths. This means that the full path names 
specified on the command line are sent to the server rather than just 
the last parts of the
filenames. This is particularly useful when you want to send several 
different directories at the same time. For example, if you used this 
command:
</dd><dt>CW rsync -av /foo/bar/baz.c remote:/tmp/</dt></dl>
<ul>
<li style="list-style: none">....
</li><li>machine. If instead you used
<blockquote>
<dl compact="compact">
<dt>CW rsync -avR /foo/bar/baz.c remote:/tmp/</dt></dl></blockquote>
<dl compact="compact">
<dt>then a file named /tmp/foo/bar/baz.c would be created on the remote
</dt><dd>machine, preserving its full path. These extra path elements 
are called lqimplied directoriesrq (i.e. the lqfoorq and the lqfoo/barrq
 directories in the
above example).
</dd><dt>Beginning with rsync 3.0.0, rsync always sends these implied directories as
</dt><dd>real directories in the file list, even if a path element is 
really a symlink on the sending side. This prevents some really 
unexpected behaviors when
copying the full path of a file that you didn't realize had a symlink in
 its path. If you want to duplicate a server-side symlink, include both 
the symlink via
its path, and referent directory via its real path. If you're dealing 
with an older rsync on the sending side, you may need to use the <b>--no-implied-dirs</b>
option.
</dd><dt>It is also possible to limit the amount of path information that is sent as
</dt><dd>implied directories for each path you specify. With a modern 
rsync on the sending side (beginning with 2.6.7), you can insert a dot 
and a slash into the
source path, like this:
</dd><dt>CW rsync -avR /foo/./bar/baz.c remote:/tmp/
</dt><dt>That would create /tmp/bar/baz.c on the remote machine. (Note that the
</dt><dd>dot must be followed by a slash, so lq/foo/.rq would not be 
abbreviated.) (2) For older rsync versions, you would need to use a 
chdir to limit the source
path. For example, when pushing files:
</dd><dt>CW (cd /foo; rsync -avR bar/baz.c remote:/tmp/)
</dt><dt>(Note that the parens put the two commands into a sub-shell, so that the
</dt><dd>lqcdrq command doesn't remain in effect for future commands.) 
If you're pulling files from an older rsync, use this idiom (but only 
for a non-daemon
transfer):
</dd><dt>CW rsync -avR --rsync-path="cd /foo; rsync" \
</dt><dd><br>
CW remote:bar/baz.c /tmp/
</dd><dt><b>--no-implied-dirs</b>
</dt><dd>This option affects the default behavior of the <b>--relative</b>
 option. When it is specified, the attributes of the implied directories
 from the source
names are not included in the transfer. This means that the 
corresponding path elements on the destination system are left unchanged
 if they exist, and any
missing implied directories are created with default attributes. This 
even allows these implied path elements to have big differences, such as
 being a symlink
to a directory on the receiving side.
</dd><dt>For instance, if a command-line arg or a files-from entry told rsync to
</dt><dd>transfer the file lqpath/foo/filerq, the directories lqpathrq and lqpath/foorq are implied when <b>--relative</b>
 is used. If lqpath/foorq is a symlink to
lqbarrq on the destination system, the receiving rsync would ordinarily 
delete lqpath/foorq, recreate it as a directory, and receive the file 
into the new
directory. With <b>--no-implied-dirs</b>, the receiving rsync updates lqpath/foo/filerq using the existing path elements, which means that the file ends up
being created in lqpath/barrq. Another way to accomplish this link preservation is to use the <b>--keep-dirlinks</b> option (which will also affect symlinks to
directories in the rest of the transfer).
</dd><dt>When pulling files from an rsync older than 3.0.0, you may need to use this
</dt><dd>option if the sending side has a symlink in the path you 
request and you wish the implied directories to be transferred as normal
 directories.
</dd><dt><b>-b, --backup</b>
</dt><dd>With this option, preexisting destination files are renamed as 
each file is transferred or deleted. You can control where the backup 
file goes and what (if
any) suffix gets appended using the <b>--backup-dir</b> and <b>--suffix</b> options.
</dd><dt>Note that if you don't specify <b>--backup-dir</b>, (1) the
</dt><dd><b>--omit-dir-times</b> option will be implied, <i>and (2)</i> if <b>--delete</b> is also in effect (without <b>--delete-excluded</b>), rsync will add a
lqprotectrq filter-rule for the backup suffix to the end of all your existing excludes (e.g. <b>-f "P *~"</b>).
 This will prevent previously backed-up files
from being deleted. Note that if you are supplying your own filter 
rules, you may need to manually insert your own exclude/protect rule 
somewhere higher up in
the list so that it has a high enough priority to be effective (e.g., if
 your rules specify a trailing inclusion/exclusion of oq*cq, the 
auto-added rule would
never be reached).
</dd><dt><b>--backup-dir=DIR</b>
</dt><dd>In combination with the <b>--backup</b> option, this tells rsync to store all backups in the specified directory on the receiving side. This can be used
for incremental backups. You can additionally specify a backup suffix using the <b>--suffix</b> option (otherwise the files backed up in the specified
directory will keep their original filenames).
</dd><dt><b>--suffix=SUFFIX</b>
</dt><dd>This option allows you to override the default backup suffix used with the <b>--backup</b> (<b>-b</b>) option. The default suffix is a ~ if no
-<b>-backup-dir</b> was specified, otherwise it is an empty string.
</dd><dt><b>-u, --update</b>
</dt><dd>This forces rsync to skip any files which exist on the 
destination and have a modified time that is newer than the source file.
 (If an existing destination
file has a modification time equal to the source file's, it will be 
updated if the sizes are different.)
</dd><dt>Note that this does not affect the copying of symlinks or other special
</dt><dd>files. Also, a difference of file format between the sender and
 receiver is always considered to be important enough for an update, no 
matter what date is
on the objects. In other words, if the source has a directory where the 
destination has a file, the transfer would occur regardless of the 
timestamps.
</dd><dt>This option is a transfer rule, not an exclude, so it doesn't affect the
</dt><dd>data that goes into the file-lists, and thus it doesn't affect 
deletions. It just limits the files that the receiver requests to be 
transferred.
</dd><dt><b>--inplace</b>
</dt><dd>This option changes how rsync transfers a file when the file's 
data needs to be updated: instead of the default method of creating a 
new copy of the file
and moving it into place when it is complete, rsync instead writes the 
updated data directly to the destination file.
</dd><dt>This has several <i>effects: (1)</i> in-use binaries cannot be updated (either the
</dt><dd>OS will prevent this from happening, or binaries that attempt 
to swap-in their data will misbehave or crash), (2) the file's data will
 be in an
inconsistent state during the transfer, (3) a file's data may be left in
 an inconsistent state after the transfer if the transfer is interrupted
 or if an
update fails, (4) a file that does not have write permissions can not be
 updated, <i>and (5)</i> the efficiency of rsync's delta-transfer 
algorithm may be
reduced if some data in the destination file is overwritten before it 
can be copied to a position later in the file (one exception to this is 
if you combine
this option with <b>--backup</b>, since rsync is smart enough to use the backup file as the basis file for the transfer).
</dd><dt>WARNING: you should not use this option to update files that are being
</dt><dd>accessed by others, so be careful when choosing to use this for a copy.
</dd><dt>This option is useful for transfer of large files with block-based changes
</dt><dd>or appended data, and also on systems that are disk bound, not network bound.
</dd><dt>The option implies <b>--partial</b> (since an interrupted transfer does not delete
</dt><dd>the file), but conflicts with <b>--partial-dir</b> and <b>--delay-updates</b>. Prior to rsync 2.6.4 <b>--inplace</b> was also incompatible with
<b>--compare-dest</b> and <b>--link-dest</b>.
</dd><dt><b>--append</b>
</dt><dd>This causes rsync to update a file by appending data onto the 
end of the file, which presumes that the data that already exists on the
 receiving side is
identical with the start of the file on the sending side. If a file 
needs to be transferred and its size on the receiver is the same or 
longer than the size on
the sender, the file is skipped. This does not interfere with the 
updating of a file's non-content attributes (e.g. permissions, 
ownership, etc.) when the file
does not need to be transferred, nor does it affect the updating of any 
non-regular files. Implies <b>--inplace</b>, but does not conflict with <b>--sparse</b>
(since it is always extending a file's length).
</dd><dt><b>--append-verify</b>
</dt><dd>This works just like the <b>--append</b> option, but the existing data on the receiving side is included in the full-file checksum verification step, which
will cause a file to be resent if the final verification step fails (rsync uses a normal, non-appending <b>--inplace</b> transfer for the resend).
</dd><dt>Note: prior to rsync 3.0.0, the <b>--append</b> option worked like
</dt><dd><b>--append-verify</b>, so if you are interacting with an older
 rsync (or the transfer is using a protocol prior to 30), specifying 
either append option
will initiate an <b>--append-verify</b> transfer.
</dd><dt><b>-d, --dirs</b>
</dt><dd>Tell the sending side to include any directories that are encountered. Unlike <b>--recursive</b>,
 a directory's contents are not copied unless the
directory name specified is lq.rq or ends with a trailing slash (e.g. 
lq.rq, lqdir/.rq, lqdir/rq, etc.). Without this option or the <b>--recursive</b> option,
rsync will skip all directories it encounters (and output a message to that effect for each one). If you specify both <b>--dirs</b> and <b>--recursive</b>,
<b>--recursive</b> takes precedence.
</dd><dt>The <b>--dirs</b> option is implied by the <b>--files-from</b> option
</dt><dd>or the <b>--list-only</b> option (including an implied <b>--list-only</b> usage) if <b>--recursive</b> wasn't specified (so that directories are seen in
the listing). Specify <b>--no-dirs</b> (or <b>--no-d</b>) if you want to turn this off.
</dd><dt>There is also a backward-compatibility helper option, <b>--old-dirs</b> (or
</dt><dd><b>--old-d</b>) that tells rsync to use a hack of lq-r --exclude='/*/*'rq to get an older rsync to list a single directory without recursing.
</dd><dt><b>-l, --links</b>
</dt><dd>When symlinks are encountered, recreate the symlink on the destination.
</dd><dt><b>-L, --copy-links</b>
</dt><dd>When symlinks are encountered, the item that they point to (the
 referent) is copied, rather than the symlink. In older versions of 
rsync, this option also
had the side-effect of telling the receiving side to follow symlinks, 
such as symlinks to directories. In a modern rsync such as this one, 
you'll need to
specify <b>--keep-dirlinks</b> (<b>-K</b>) to get this extra behavior. The only exception is when sending files to an rsync that is too old to understand
<b>-K</b> -- in that case, the <b>-L</b> option will still have the side-effect of <b>-K</b> on that older receiving rsync.
</dd><dt><b>--copy-unsafe-links</b>
</dt><dd>This tells rsync to copy the referent of symbolic links that 
point outside the copied tree. Absolute symlinks are also treated like 
ordinary files, and so
are any symlinks in the source path itself when <b>--relative</b> is used. This option has no additional effect if <b>--copy-links</b> was also specified.
</dd><dt><b>--safe-links</b>
</dt><dd>This tells rsync to ignore any symbolic links which point 
outside the copied tree. All absolute symlinks are also ignored. Using 
this option in conjunction
with <b>--relative</b> may give unexpected results.
</dd><dt><b>-k, --copy-dirlinks</b>
</dt><dd>This option causes the sending side to treat a symlink to a 
directory as though it were a real directory. This is useful if you 
don't want symlinks to
non-directories to be affected, as they would be using <b>--copy-links</b>.
</dd><dt>Without this option, if the sending side has replaced a directory with a
</dt><dd>symlink to a directory, the receiving side will delete anything
 that is in the way of the new symlink, including a directory hierarchy 
(as long as
<b>--force</b> or <b>--delete</b> is in effect).
</dd><dt>See also <b>--keep-dirlinks</b> for an analogous option for the receiving
</dt><dd>side.
</dd><dt><b>-K, --keep-dirlinks</b>
</dt><dd>This option causes the receiving side to treat a symlink to a 
directory as though it were a real directory, but only if it matches a 
real directory from
the sender. Without this option, the receiver's symlink would be deleted
 and replaced with a real directory.
</dd><dt>For example, suppose you transfer a directory lqfoorq that contains a file
</dt><dd>lqfilerq, but lqfoorq is a symlink to directory lqbarrq on the receiver. Without <b>--keep-dirlinks</b>, the receiver deletes symlink lqfoorq, recreates it
as a directory, and receives the file into the new directory. With <b>--keep-dirlinks</b>, the receiver keeps the symlink and lqfilerq ends up in lqbarrq.
</dd><dt>One note of caution: if you use <b>--keep-dirlinks</b>, you must trust all
</dt><dd>the symlinks in the copy! If it is possible for an untrusted 
user to create their own symlink to any directory, the user could then 
(on a subsequent copy)
replace the symlink with a real directory and affect the content of 
whatever directory the symlink references. For backup copies, you are 
better off using
something like a bind mount instead of a symlink to modify your 
receiving hierarchy.
</dd><dt>See also <b>--copy-dirlinks</b> for an analogous option for the sending side.
</dt><dt><b>-H, --hard-links</b>
</dt><dd>This tells rsync to look for hard-linked files in the transfer 
and link together the corresponding files on the receiving side. Without
 this option,
hard-linked files in the transfer are treated as though they were 
separate files.
</dd><dt>When you are updating a non-empty destination, this option only ensures
</dt><dd>that files that are hard-linked together on the source are 
hard-linked together on the destination. It does NOT currently endeavor 
to break already
existing hard links on the destination that do not exist between the 
source files. Note, however, that if one or more extra-linked files have
 content changes,
they will become unlinked when updated (assuming you are not using the <b>--inplace</b> option).
</dd><dt>Note that rsync can only detect hard links between files that are inside
</dt><dd>the transfer set. If rsync updates a file that has extra 
hard-link connections to files outside the transfer, that linkage will 
be broken. If you are
tempted to use the <b>--inplace</b> option to avoid this breakage, be very careful that you know how your files are being updated so that you are certain that
no unintended changes happen due to lingering hard links (and see the <b>--inplace</b> option for more caveats).
</dd><dt>If incremental recursion is active (see <b>--recursive</b>), rsync may transfer
</dt><dd>a missing hard-linked file before it finds that another link 
for that contents exists elsewhere in the hierarchy. This does not 
affect the accuracy of the
transfer, just its efficiency. One way to avoid this is to disable 
incremental recursion using the <b>--no-inc-recursive</b> option.
</dd><dt><b>-p, --perms</b>
</dt><dd>This option causes the receiving rsync to set the destination 
permissions to be the same as the source permissions. (See also the <b>--chmod</b> option for
a way to modify what rsync considers to be the source permissions.)
</dd><dt>When this option is <i>off</i>, permissions are set as follows:
</dt><dt>o
</dt><dd>Existing files (including updated files) retain their existing permissions, though the <b>--executability</b> option might change just the execute
permission for the file.
</dd><dt>o
</dt><dd>New files get their lqnormalrq permission bits set to the 
source file's permissions masked with the receiving directory's default 
permissions (either the
receiving process's umask, or the permissions specified via the 
destination directory's default ACL), and their special permission bits 
disabled except in the
case where a new directory inherits a setgid bit from its parent 
directory.
</dd><dt>Thus, when <b>--perms</b> and <b>--executability</b> are both disabled,
</dt><dd>rsync's behavior is the same as that of other file-copy utilities, such as <i><b><a href="http://linux.die.net/man/1/cp">cp</a></b>(1)</i> and <i><b><a href="http://linux.die.net/man/1/tar">tar</a></b>(1)</i>.
</dd><dt>In summary: to give destination files (both old and new) the source
</dt><dd>permissions, use <b>--perms</b>. To give new files the destination-default permissions (while leaving existing files unchanged), make sure that the
<b>--perms</b> option is off and use <b>--chmod=ugo=rwX</b> (which ensures that all non-masked bits get enabled). If you'd care to make this latter behavior
easier to type, you could define a popt alias for it, such as putting this line in the file ~/.popt (the following defines the <b>-Z</b> option, and includes
--no-g to use the default group of the destination dir):
</dd><dt>CW rsync alias -Z --no-p --no-g --chmod=ugo=rwX
</dt><dt>You could then use this new option in a command such as this one:
</dt><dt>CW rsync -avZ src/ dest/
</dt><dt>(Caveat: make sure that <b>-a</b> does not follow <b>-Z</b>, or it will re-enable
</dt><dd>the two lq--no-*rq options mentioned above.)
</dd><dt>The preservation of the destination's setgid bit on newly-created
</dt><dd>directories when <b>--perms</b> is off was added in rsync 2.6.7. Older rsync versions erroneously preserved the three special permission bits for
newly-created files when <b>--perms</b> was off, while overriding the 
destination's setgid bit setting on a newly-created directory. Default 
ACL observance was
added to the ACL patch for rsync 2.6.7, so older (or non-ACL-enabled) 
rsyncs use the umask even if default ACLs are present. (Keep in mind 
that it is the
version of the receiving rsync that affects these behaviors.)
</dd><dt><b>-E, --executability</b>
</dt><dd>This option causes rsync to preserve the executability (or non-executability) of regular files when <b>--perms</b>
 is not enabled. A regular file is
considered to be executable if at least one oqxcq is turned on in its 
permissions. When an existing destination file's executability differs 
from that of the
corresponding source file, rsync modifies the destination file's 
permissions as follows:
</dd><dt>o
</dt><dd>To make a file non-executable, rsync turns off all its oqxcq permissions.
</dd><dt>o
</dt><dd>To make a file executable, rsync turns on each oqxcq permission that has a corresponding oqrcq permission enabled.
</dd><dt>If <b>--perms</b> is enabled, this option is ignored.
</dt><dt><b>-A, --acls</b>
</dt><dd>This option causes rsync to update the destination ACLs to be the same as the source ACLs. The option also implies <b>--perms</b>.
</dd><dt>The source and destination systems must have compatible ACL entries for this
</dt><dd>option to work properly. See the <b>--fake-super</b> option for a way to backup and restore ACLs that are not compatible.
</dd><dt><b>-X, --xattrs</b>
</dt><dd>This option causes rsync to update the remote extended attributes to be the same as the local ones.
</dd><dt>For systems that support extended-attribute namespaces, a copy being done by a
</dt><dd>super-user copies all namespaces except system.*. A normal user
 only copies the user.* namespace. To be able to backup and restore 
non-user namespaces as a
normal user, see the <b>--fake-super</b> option.
</dd><dt><b>--chmod</b>
</dt><dd>This option tells rsync to apply one or more comma-separated 
lqchmodrq strings to the permission of the files in the transfer. The 
resulting value is
treated as though it was the permissions that the sending side supplied 
for the file, which means that this option can seem to have no effect on
 existing files
if <b>--perms</b> is not enabled.
</dd><dt>In addition to the normal parsing rules specified in the <i><b><a href="http://linux.die.net/man/1/chmod">chmod</a></b>(1)</i>
</dt><dd>manpage, you can specify an item that should only apply to a 
directory by prefixing it with a oqDcq, or specify an item that should 
only apply to a file by
prefixing it with a oqFcq. For example:
</dd><dt>--chmod=Dg+s,ug+w,Fo-w,+X
</dt><dt>It is also legal to specify multiple <b>--chmod</b> options, as each
</dt><dd>additional option is just appended to the list of changes to make.
</dd><dt>See the <b>--perms</b> and <b>--executability</b> options for how the resulting
</dt><dd>permission value can be applied to the files in the transfer.
</dd><dt><b>-o, --owner</b>
</dt><dd>This option causes rsync to set the owner of the destination 
file to be the same as the source file, but only if the receiving rsync 
is being run as the
super-user (see also the <b>--super</b> and <b>--fake-super</b> options). Without this option, the owner of new and/or transferred files are set to the
invoking user on the receiving side.
</dd><dt>The preservation of ownership will associate matching names by default, but
</dt><dd>may fall back to using the ID number in some circumstances (see also the <b>--numeric-ids</b> option for a full discussion).
</dd><dt><b>-g, --group</b>
</dt><dd>This option causes rsync to set the group of the destination 
file to be the same as the source file. If the receiving program is not 
running as the
super-user (or if <b>--no-super</b> was specified), only groups that the invoking user on the receiving side is a member of will be preserved. Without this
option, the group is set to the default group of the invoking user on the receiving side.
</dd><dt>The preservation of group information will associate matching names by
</dt><dd>default, but may fall back to using the ID number in some circumstances (see also the <b>--numeric-ids</b> option for a full discussion).
</dd><dt><b>--devices</b>
</dt><dd>This option causes rsync to transfer character and block device
 files to the remote system to recreate these devices. This option has 
no effect if the
receiving rsync is not run as the super-user (see also the <b>--super</b> and <b>--fake-super</b> options).
</dd><dt><b>--specials</b>
</dt><dd>This option causes rsync to transfer special files such as named sockets and fifos.
</dd><dt><b>-D</b>
</dt><dd>The <b>-D</b> option is equivalent to <b>--devices --specials</b>.
</dd><dt><b>-t, --times</b>
</dt><dd>This tells rsync to transfer modification times along with the 
files and update them on the remote system. Note that if this option is 
not used, the
optimization that excludes files that have not been modified cannot be 
effective; in other words, a missing <b>-t</b> or <b>-a</b> will cause the next transfer
to behave as if it used <b>-I</b>, causing all files to be updated (though rsync's delta-transfer algorithm will make the update fairly efficient if the files
haven't actually changed, you're much better off using <b>-t</b>).
</dd><dt><b>-O, --omit-dir-times</b>
</dt><dd>This tells rsync to omit directories when it is preserving modification times (see <b>--times</b>). If NFS is sharing the directories on the receiving
side, it is a good idea to use <b>-O</b>. This option is inferred if you use <b>--backup</b> without <b>--backup-dir</b>.
</dd><dt><b>--super</b>
</dt><dd>This tells the receiving side to attempt super-user activities 
even if the receiving rsync wasn't run by the super-user. These 
activities include:
preserving users via the <b>--owner</b> option, preserving all groups (not just the current user's groups) via the <b>--groups</b> option, and copying devices
via the <b>--devices</b> option. This is useful for systems that allow 
such activities without being the super-user, and also for ensuring that
 you will get
errors if the receiving side isn't being run as the super-user. To turn 
off super-user activities, the super-user can use <b>--no-super</b>.
</dd><dt><b>--fake-super</b>
</dt><dd>When this option is enabled, rsync simulates super-user 
activities by saving/restoring the privileged attributes via special 
extended attributes that are
attached to each file (as needed). This includes the file's owner and 
group (if it is not the default), the file's device info (device &amp; 
special files are
created as empty text files), and any permission bits that we won't 
allow to be set on the real file (e.g. the real file gets u-s,g-s,o-t 
for safety) or that
would limit the owner's access (since the real super-user can always 
access/change a file, the files we create can always be accessed/changed
 by the creating
user). This option also handles ACLs (if <b>--acls</b> was specified) and non-user extended attributes (if <b>--xattrs</b> was specified).
</dd><dt>This is a good way to backup data without using a super-user, and to store
</dt><dd>ACLs from incompatible systems.
</dd><dt>The <b>--fake-super</b> option only affects the side where the option is used.
</dt><dd>To affect the remote side of a remote-shell connection, specify an rsync path:
</dd><dt>CW rsync -av --rsync-path="rsync --fake-super" /src/ host:/dest/
</dt><dt>Since there is only one lqsiderq in a local copy, this option affects both
</dt><dd>the sending and receiving of files. You'll need to specify a 
copy using lqlocalhostrq if you need to avoid this, possibly using the 
lqlshrq shell script
(from the support directory) as a substitute for an actual remote shell 
(see <b>--rsh</b>).
</dd><dt>This option is overridden by both <b>--super</b> and <b>--no-super</b>.
</dt><dt>See also the lqfake superrq setting in the daemon's rsyncd.conf file.
</dt><dt><b>-S, --sparse</b>
</dt><dd>Try to handle sparse files efficiently so they take up less space on the destination. Conflicts with <b>--inplace</b> because it's not possible to
overwrite data in a sparse fashion.
</dd><dt>NOTE: Don't use this option when the destination is a Solaris lqtmpfsrq
</dt><dd>filesystem. It doesn't seem to handle seeks over null regions correctly and ends up corrupting the files.
</dd><dt><b>-n, --dry-run</b>
</dt><dd>This makes rsync perform a trial run that doesn't make any 
changes (and produces mostly the same output as a real run). It is most 
commonly used in
combination with the <b>-v, --verbose</b> and/or <b>-i, --itemize-changes</b> options to see what an rsync command is going to do before one actually runs it.
</dd><dt>The output of <b>--itemize-changes</b> is supposed to be exactly the same on a
</dt><dd>dry run and a subsequent real run (barring intentional trickery
 and system call failures); if it isn't, that's a bug. Other output is 
the same to the
extent practical, but may differ in some areas. Notably, a dry run does 
not send the actual data for file transfers, so <b>--progress</b> has no
 effect, the
lqbytes sentrq, lqbytes receivedrq, lqliteral datarq, and lqmatched 
datarq statistics are too small, and the lqspeeduprq value is equivalent
 to a run where no
file transfers are needed.
</dd><dt><b>-W, --whole-file</b>
</dt><dd>With this option rsync's delta-transfer algorithm is not used 
and the whole file is sent as-is instead. The transfer may be faster if 
this option is used
when the bandwidth between the source and destination machines is higher
 than the bandwidth to disk (especially when the lqdiskrq is actually a 
networked
filesystem). This is the default when both the source and destination 
are specified as local paths.
</dd><dt><b>-x, --one-file-system</b>
</dt><dd>This tells rsync to avoid crossing a filesystem boundary when 
recursing. This does not limit the user's ability to specify items to 
copy from multiple
filesystems, just rsync's recursion through the hierarchy of each 
directory that the user specified, and also the analogous recursion on 
the receiving side
during deletion. Also keep in mind that rsync treats a lqbindrq mount to
 the same device as being on the same filesystem.
</dd><dt>If this option is repeated, rsync omits all mount-point directories from
</dt><dd>the copy. Otherwise, it includes an empty directory at each 
mount-point it encounters (using the attributes of the mounted directory
 because those of the
underlying mount-point directory are inaccessible).
</dd><dt>If rsync has been told to collapse symlinks (via <b>--copy-links</b> or
</dt><dd><b>--copy-unsafe-links</b>), a symlink to a directory on another device is treated like a mount-point. Symlinks to non-directories are unaffected by this
option.
</dd><dt><b>--existing, --ignore-non-existing</b>
</dt><dd>This tells rsync to skip creating files (including directories)
 that do not exist yet on the destination. If this option is combined 
with the
<b>--ignore-existing</b> option, no files will be updated (which can be useful if all you want to do is delete extraneous files).
</dd><dt>This option is a transfer rule, not an exclude, so it doesn't affect the
</dt><dd>data that goes into the file-lists, and thus it doesn't affect 
deletions. It just limits the files that the receiver requests to be 
transferred.
</dd><dt><b>--ignore-existing</b>
</dt><dd>This tells rsync to skip updating files that already exist on the destination (this does <i>not</i> ignore existing directories, or nothing would get
done). See also <b>--existing</b>.
</dd><dt>This option is a transfer rule, not an exclude, so it doesn't affect the
</dt><dd>data that goes into the file-lists, and thus it doesn't affect 
deletions. It just limits the files that the receiver requests to be 
transferred.
</dd><dt>This option can be useful for those doing backups using the <b>--link-dest</b>
</dt><dd>option when they need to continue a backup run that got interrupted. Since a <b>--link-dest</b> run is copied into a new directory hierarchy (when it is
used properly), using <b>--ignore existing</b> will ensure that the already-handled files don't get tweaked (which avoids a change in permissions on the
hard-linked files). This does mean that this option is only looking at the existing files in the destination hierarchy itself.
</dd><dt><b>--remove-source-files</b>
</dt><dd>This tells rsync to remove from the sending side the files 
(meaning non-directories) that are a part of the transfer and have been 
successfully duplicated
on the receiving side.
</dd><dt><b>--delete</b>
</dt><dd>This tells rsync to delete extraneous files from the receiving 
side (ones that aren't on the sending side), but only for the 
directories that are being
synchronized. You must have asked rsync to send the whole directory 
(e.g. lqdirrq or lqdir/rq) without using a wildcard for the directory's 
contents (e.g.
lqdir/*rq) since the wildcard is expanded by the shell and rsync thus 
gets a request to transfer individual files, not the files' parent 
directory. Files that
are excluded from the transfer are also excluded from being deleted 
unless you use the <b>--delete-excluded</b> option or mark the rules as only matching on
the sending side (see the include/exclude modifiers in the FILTER RULES section).
</dd><dt>Prior to rsync 2.6.7, this option would have no effect unless <b>--recursive</b>
</dt><dd>was enabled. Beginning with 2.6.7, deletions will also occur when <b>--dirs</b> (<b>-d</b>) is enabled, but only for directories whose contents are being
copied.
</dd><dt>This option can be dangerous if used incorrectly! It is a very good idea to
</dt><dd>first try a run using the <b>--dry-run</b> option (<b>-n</b>) to see what files are going to be deleted.
</dd><dt>If the sending side detects any I/O errors, then the deletion of any
</dt><dd>files at the destination will be automatically disabled. This 
is to prevent temporary filesystem failures (such as NFS errors) on the 
sending side causing
a massive deletion of files on the destination. You can override this 
with the <b>--ignore-errors</b> option.
</dd><dt>The <b>--delete</b> option may be combined with one of the --delete-WHEN options
</dt><dd>without conflict, as well as <b>--delete-excluded</b>. However, if none of the --delete-WHEN options are specified, rsync will choose the
<b>--delete-during</b> algorithm when talking to rsync 3.0.0 or newer, and the <b>--delete-before</b> algorithm when talking to an older rsync. See also
<b>--delete-delay</b> and <b>--delete-after</b>.
</dd><dt><b>--delete-before</b>
</dt><dd>Request that the file-deletions on the receiving side be done before the transfer starts. See <b>--delete</b> (which is implied) for more details on
file-deletion.
</dd><dt>Deleting before the transfer is helpful if the filesystem is tight for space
</dt><dd>and removing extraneous files would help to make the transfer 
possible. However, it does introduce a delay before the start of the 
transfer, and this delay
might cause the transfer to timeout (if <b>--timeout</b> was specified). It also forces rsync to use the old, non-incremental recursion algorithm that requires
rsync to scan all the files in the transfer into memory at once (see <b>--recursive</b>).
</dd><dt><b>--delete-during, --del</b>
</dt><dd>Request that the file-deletions on the receiving side be done 
incrementally as the transfer happens. The per-directory delete scan is 
done right before
each directory is checked for updates, so it behaves like a more 
efficient <b>--delete-before</b>, including doing the deletions prior to any per-directory
filter files being updated. This option was first added in rsync version 2.6.4. See <b>--delete</b> (which is implied) for more details on file-deletion.
</dd><dt><b>--delete-delay</b>
</dt><dd>Request that the file-deletions on the receiving side be computed during the transfer (like <b>--delete-during</b>), and then removed after the transfer
completes. This is useful when combined with <b>--delay-updates</b> and/or <b>--fuzzy</b>, and is more efficient than using <b>--delete-after</b> (but can
behave differently, since <b>--delete-after</b> computes the deletions 
in a separate pass after all updates are done). If the number of removed
 files overflows
an internal buffer, a temporary file will be created on the receiving 
side to hold the names (it is removed while open, so you shouldn't see 
it during the
transfer). If the creation of the temporary file fails, rsync will try 
to fall back to using <b>--delete-after</b> (which it cannot do if <b>--recursive</b> is
doing an incremental scan). See <b>--delete</b> (which is implied) for more details on file-deletion.
</dd><dt><b>--delete-after</b>
</dt><dd>Request that the file-deletions on the receiving side be done 
after the transfer has completed. This is useful if you are sending new 
per-directory merge
files as a part of the transfer and you want their exclusions to take 
effect for the delete phase of the current transfer. It also forces 
rsync to use the old,
non-incremental recursion algorithm that requires rsync to scan all the 
files in the transfer into memory at once (see <b>--recursive</b>). See <b>--delete</b>
(which is implied) for more details on file-deletion.
</dd><dt><b>--delete-excluded</b>
</dt><dd>In addition to deleting the files on the receiving side that 
are not on the sending side, this tells rsync to also delete any files 
on the receiving side
that are excluded (see <b>--exclude</b>). See the FILTER RULES section for a way to make individual exclusions behave this way on the receiver, and for a way
to protect files from <b>--delete-excluded</b>. See <b>--delete</b> (which is implied) for more details on file-deletion.
</dd><dt><b>--ignore-errors</b>
</dt><dd>Tells <b>--delete</b> to go ahead and delete files even when there are I/O errors.
</dd><dt><b>--force</b>
</dt><dd>This option tells rsync to delete a non-empty directory when it
 is to be replaced by a non-directory. This is only relevant if 
deletions are not active
(see <b>--delete</b> for details).
</dd><dt>Note for older rsync versions: <b>--force</b> used to still be required when
</dt><dd>using <b>--delete-after</b>, and it used to be non-functional unless the <b>--recursive</b> option was also enabled.
</dd><dt><b>--max-delete=NUM</b>
</dt><dd>This tells rsync not to delete more than NUM files or 
directories. If that limit is exceeded, a warning is output and rsync 
exits with an error code of 25
(new for 3.0.0).
</dd><dt>Also new for version 3.0.0, you may specify <b>--max-delete=0</b> to be warned
</dt><dd>about any extraneous files in the destination without removing 
any of them. Older clients interpreted this as lqunlimitedrq, so if you 
don't know what
version the client is, you can use the less obvious <b>--max-delete=-1</b> as a backward-compatible way to specify that no deletions be allowed (though older
versions didn't warn when the limit was exceeded).
</dd><dt><b>--max-size=SIZE</b>
</dt><dd>This tells rsync to avoid transferring any file that is larger 
than the specified SIZE. The SIZE value can be suffixed with a string to
 indicate a size
multiplier, and may be a fractional value (e.g. lq<b>--max-size=1.5m</b>rq).
</dd><dt>This option is a transfer rule, not an exclude, so it doesn't affect the
</dt><dd>data that goes into the file-lists, and thus it doesn't affect 
deletions. It just limits the files that the receiver requests to be 
transferred.
</dd><dt>The suffixes are as follows: lqKrq (or lqKiBrq) is a kibibyte (1024),
</dt><dd>lqMrq (or lqMiBrq) is a mebibyte (1024*1024), and lqGrq (or 
lqGiBrq) is a gibibyte (1024*1024*1024). If you want the multiplier to 
be 1000 instead of 1024,
use lqKBrq, lqMBrq, or lqGBrq. (Note: lower-case is also accepted for 
all values.) Finally, if the suffix ends in either lq+1rq or lq-1rq, the
 value will be
offset by one byte in the indicated direction.
</dd><dt>Examples: --max-size=1.5mb-1 is 1499999 bytes, and --max-size=2g+1 is
</dt><dd>2147483649 bytes.
</dd><dt><b>--min-size=SIZE</b>
</dt><dd>This tells rsync to avoid transferring any file that is smaller
 than the specified SIZE, which can help in not transferring small, junk
 files. See the
<b>--max-size</b> option for a description of SIZE and other information.
</dd><dt><b>-B, --block-size=BLOCKSIZE</b>
</dt><dd>This forces the block size used in rsync's delta-transfer 
algorithm to a fixed value. It is normally selected based on the size of
 each file being updated.
See the technical report for details.
</dd><dt><b>-e, --rsh=COMMAND</b>
</dt><dd>This option allows you to choose an alternative remote shell 
program to use for communication between the local and remote copies of 
rsync. Typically,
rsync is configured to use ssh by default, but you may prefer to use rsh
 on a local network.
</dd><dt>If this option is used with <b>[user@]host::module/path</b>, then the
</dt><dd>remote shell <i>COMMAND</i> will be used to run an rsync daemon
 on the remote host, and all data will be transmitted through that 
remote shell connection,
rather than through a direct socket connection to a running rsync daemon
 on the remote host. See the section lqUSING RSYNC-DAEMON FEATURES VIA A
 REMOTE-SHELL
CONNECTIONrq above.
</dd><dt>Command-line arguments are permitted in COMMAND provided that COMMAND is
</dt><dd>presented to rsync as a single argument. You must use spaces 
(not tabs or other whitespace) to separate the command and args from 
each other, and you can
use single- and/or double-quotes to preserve spaces in an argument (but 
not backslashes). Note that doubling a single-quote inside a 
single-quoted string gives
you a single-quote; likewise for double-quotes (though you need to pay 
attention to which quotes your shell is parsing and which quotes rsync 
is parsing). Some
examples:
</dd><dt>CW -e 'ssh -p 2234'
</dt><dd><br>
CW -e 'ssh -o "ProxyCommand nohup ssh firewall nc -w1 %h %p"'<br>
</dd><dt>(Note that ssh users can alternately customize site-specific connect
</dt><dd>options in their .ssh/config file.)
</dd><dt>You can also choose the remote shell program using the RSYNC_RSH
</dt><dd>environment variable, which accepts the same range of values as <b>-e</b>.
</dd><dt>See also the <b>--blocking-io</b> option which is affected by this option.
</dt><dt><b>--rsync-path=PROGRAM</b>
</dt><dd>Use this to specify what program is to be run on the remote 
machine to start-up rsync. Often used when rsync is not in the default 
remote-shell's path
(e.g. --rsync-path=/usr/local/bin/rsync). Note that PROGRAM is run with 
the help of a shell, so it can be any program, script, or command 
sequence you'd care
to run, so long as it does not corrupt the standard-in &amp; 
standard-out that rsync is using to communicate.
</dd><dt>One tricky example is to set a different default directory on the remote
</dt><dd>machine for use with the <b>--relative</b> option. For instance:
</dd><dt>CW rsync -avR --rsync-path="cd /a/b &amp;&amp; rsync" host:c/d /e/
</dt><dt><b>-C, --cvs-exclude</b>
</dt><dd>This is a useful shorthand for excluding a broad range of files
 that you often don't want to transfer between systems. It uses a 
similar algorithm to CVS
to determine if a file should be ignored.
</dd><dt>The exclude list is initialized to exclude the following items (these
</dt><dd>initial items are marked as perishable -- see the FILTER RULES section):
</dd><dt>CWRCS SCCS CVS CVS.adm RCSLOG cvslog.* tags TAGS .make.state
</dt><dd>.nse_depinfo *~ #* .#* ,* _$* *$ *.old *.bak *.BAK *.orig *.rej
 .del-* *.a *.olb *.o *.obj *.so *.exe *.Z *.elc *.ln core .svn/ .git/ 
.bzr/
</dd><dt>then, files listed in a $HOME/.cvsignore are added to the list and any
</dt><dd>files listed in the CVSIGNORE environment variable (all cvsignore names are delimited by whitespace).
</dd><dt>Finally, any file is ignored if it is in the same directory as a
</dt><dd>.cvsignore file and matches one of the patterns listed therein.
 Unlike rsync's filter/exclude files, these patterns are split on 
whitespace. See the
<i><b><a href="http://linux.die.net/man/1/cvs">cvs</a></b>(1)</i> manual for more information.
</dd><dt>If you're combining <b>-C</b> with your own <b>--filter</b> rules, you should
</dt><dd>note that these CVS excludes are appended at the end of your own rules, regardless of where the <b>-C</b>
 was placed on the command-line. This makes them a
lower priority than any rules you specified explicitly. If you want to 
control where these CVS excludes get inserted into your filter rules, 
you should omit
the <b>-C</b> as a command-line option and use a combination of <b>--filter=:C</b> and <b>--filter=-C</b>
 (either on your command-line or by putting the lq:Crq
and lq-Crq rules into a filter file with your other rules). The first 
option turns on the per-directory scanning for the .cvsignore file. The 
second option
does a one-time import of the CVS excludes mentioned above.
</dd><dt><b>-f, --filter=RULE</b>
</dt><dd>This option allows you to add rules to selectively exclude 
certain files from the list of files to be transferred. This is most 
useful in combination with
a recursive transfer.
</dd><dt>You may use as many <b>--filter</b> options on the command line as you like
</dt><dd>to build up the list of files to exclude. If the filter 
contains whitespace, be sure to quote it so that the shell gives the 
rule to rsync as a single
argument. The text below also mentions that you can use an underscore to
 replace the space that separates a rule from its arg.
</dd><dt>See the FILTER RULES section for detailed information on this option.
</dt><dt><b>-F</b>
</dt><dd>The <b>-F</b> option is a shorthand for adding two <b>--filter</b> rules to your command. The first time it is used is a shorthand for this rule:
</dd><dt>CW --filter='dir-merge /.rsync-filter'
</dt><dt>This tells rsync to look for per-directory .rsync-filter files that have
</dt><dd>been sprinkled through the hierarchy and use their rules to filter the files in the transfer. If <b>-F</b> is repeated, it is a shorthand for this rule:
</dd><dt>CW --filter='exclude .rsync-filter'
</dt><dt>This filters out the .rsync-filter files themselves from the transfer.
</dt><dt>See the FILTER RULES section for detailed information on how these options
</dt><dd>work.
</dd><dt><b>--exclude=PATTERN</b>
</dt><dd>This option is a simplified form of the <b>--filter</b> option that defaults to an exclude rule and does not allow the full rule-parsing syntax of normal
filter rules.
</dd><dt>See the FILTER RULES section for detailed information on this option.
</dt><dt><b>--exclude-from=FILE</b>
</dt><dd>This option is related to the <b>--exclude</b> option, but it specifies a FILE that contains exclude patterns (one per line). Blank lines in the file and
lines starting with oq;cq or oq#cq are ignored. If <i>FILE</i> is <b>-</b>, the list will be read from standard input.
</dd><dt><b>--include=PATTERN</b>
</dt><dd>This option is a simplified form of the <b>--filter</b> option that defaults to an include rule and does not allow the full rule-parsing syntax of normal
filter rules.
</dd><dt>See the FILTER RULES section for detailed information on this option.
</dt><dt><b>--include-from=FILE</b>
</dt><dd>This option is related to the <b>--include</b> option, but it specifies a FILE that contains include patterns (one per line). Blank lines in the file and
lines starting with oq;cq or oq#cq are ignored. If <i>FILE</i> is <b>-</b>, the list will be read from standard input.
</dd><dt><b>--files-from=FILE</b>
</dt><dd>Using this option allows you to specify the exact list of files to transfer (as read from the specified FILE or <b>-</b> for standard input). It also
tweaks the default behavior of rsync to make transferring just the specified files and directories easier:
</dd><dt>o
</dt><dd>The <b>--relative</b> (<b>-R</b>) option is implied, which preserves the path information that is specified for each item in the file (use
<b>--no-relative</b> or <b>--no-R</b> if you want to turn that off).
</dd><dt>o
</dt><dd>The <b>--dirs</b> (<b>-d</b>) option is implied, which will create directories specified in the list on the destination rather than noisily skipping them
(use <b>--no-dirs</b> or <b>--no-d</b> if you want to turn that off).
</dd><dt>o
</dt><dd>The <b>--archive</b> (<b>-a</b>) option's behavior does not imply <b>--recursive</b> (<b>-r</b>), so specify it explicitly, if you want it.
</dd><dt>o
</dt><dd>These side-effects change the default state of rsync, so the position of the <b>--files-from</b> option on the command-line has no bearing on how other
options are parsed (e.g. <b>-a</b> works the same before or after <b>--files-from</b>, as does <b>--no-R</b> and all other options).
</dd><dt>The filenames that are read from the FILE are all relative to the
</dt><dd>source dir -- any leading slashes are removed and no lq..rq 
references are allowed to go higher than the source dir. For example, 
take this command:
</dd><dt>CW rsync -a --files-from=/tmp/foo /usr remote:/backup
</dt><dt>If /tmp/foo contains the string lqbinrq (or even lq/binrq), the /usr/bin
</dt><dd>directory will be created as /backup/bin on the remote host. If
 it contains lqbin/rq (note the trailing slash), the immediate contents 
of the directory
would also be sent (without needing to be explicitly mentioned in the 
file -- this began in version 2.6.4). In both cases, if the <b>-r</b> option was enabled,
that dir's entire hierarchy would also be transferred (keep in mind that <b>-r</b> needs to be specified explicitly with <b>--files-from</b>, since it is not
implied by <b>-a</b>). Also note that the effect of the (enabled by default) <b>--relative</b> option is to duplicate only the path info that is read from the
file -- it does not force the duplication of the source-spec path (/usr in this case).
</dd><dt>In addition, the <b>--files-from</b> file can be read from the remote host
</dt><dd>instead of the local host if you specify a lqhost:rq in front 
of the file (the host must match one end of the transfer). As a 
short-cut, you can specify
just a prefix of lq:rq to mean lquse the remote end of the transferrq. 
For example:
</dd><dt>CW rsync -a --files-from=:/path/file-list src:/ /tmp/copy
</dt><dt>This would copy all the files specified in the /path/file-list file that
</dt><dd>was located on the remote lqsrcrq host.
</dd><dt><b>-0, --from0</b>
</dt><dd>This tells rsync that the rules/filenames it reads from a file 
are terminated by a null ('\0') character, not a NL, CR, or CR+LF. This 
affects
<b>--exclude-from</b>, <b>--include-from</b>, <b>--files-from</b>, and any merged files specified in a <b>--filter</b> rule. It does not affect
<b>--cvs-exclude</b> (since all names read from a .cvsignore file are split on whitespace).
</dd><dt>If the <b>--iconv</b> and <b>--protect-args</b> options are specified and the
</dt><dd><b>--files-from</b> filenames are being sent from one host to 
another, the filenames will be translated from the sending host's 
charset to the receiving
host's charset.
</dd><dt><b>-s, --protect-args</b>
</dt><dd>This option sends all filenames and some options to the remote 
rsync without allowing the remote shell to interpret them. This means 
that spaces are not
split in names, and any non-wildcard special characters are not 
translated (such as ~, $, ;, &amp;, etc.). Wildcards are expanded on the
 remote host by rsync
(instead of the shell doing it).
</dd><dt>If you use this option with <b>--iconv</b>, the args will also be translated
</dt><dd>from the local to the remote character-set. The translation happens before wild-cards are expanded. See also the <b>--files-from</b> option.
</dd><dt><b>-T, --temp-dir=DIR</b>
</dt><dd>This option instructs rsync to use DIR as a scratch directory 
when creating temporary copies of the files transferred on the receiving
 side. The default
behavior is to create each temporary file in the same directory as the 
associated destination file.
</dd><dt>This option is most often used when the receiving disk partition does not
</dt><dd>have enough free space to hold a copy of the largest file in 
the transfer. In this case (i.e. when the scratch directory is on a 
different disk partition),
rsync will not be able to rename each received temporary file over the 
top of the associated destination file, but instead must copy it into 
place. Rsync does
this by copying the file over the top of the destination file, which 
means that the destination file will contain truncated data during this 
copy. If this were
not done this way (even if the destination file were first removed, the 
data locally copied to a temporary file in the destination directory, 
and then renamed
into place) it would be possible for the old file to continue taking up 
disk space (if someone had it open), and thus there might not be enough 
room to fit the
new version on the disk at the same time.
</dd><dt>If you are using this option for reasons other than a shortage of disk
</dt><dd>space, you may wish to combine it with the <b>--delay-updates</b>
 option, which will ensure that all copied files get put into 
subdirectories in the
destination hierarchy, awaiting the end of the transfer. If you don't 
have enough room to duplicate all the arriving files on the destination 
partition,
another way to tell rsync that you aren't overly concerned about disk 
space is to use the <b>--partial-dir</b> option with a relative path; 
because this tells
rsync that it is OK to stash off a copy of a single file in a subdir in 
the destination hierarchy, rsync will use the partial-dir as a staging 
area to bring
over the copied file, and then rename it into place from there. 
(Specifying a <b>--partial-dir</b> with an absolute path does not have this side-effect.)
</dd><dt><b>-y, --fuzzy</b>
</dt><dd>This option tells rsync that it should look for a basis file 
for any destination file that is missing. The current algorithm looks in
 the same directory as
the destination file for either a file that has an identical size and 
modified-time, or a similarly-named file. If found, rsync uses the fuzzy
 basis file to
try to speed up the transfer.
</dd><dt>Note that the use of the <b>--delete</b> option might get rid of any potential
</dt><dd>fuzzy-match files, so either use <b>--delete-after</b> or specify some filename exclusions if you need to prevent this.
</dd><dt><b>--compare-dest=DIR</b>
</dt><dd>This option instructs rsync to use <i>DIR</i> on the destination machine as an additional hierarchy to compare destination files against doing transfers
(if the files are missing in the destination directory). If a file is found in <i>DIR</i>
 that is identical to the sender's file, the file will NOT be
transferred to the destination directory. This is useful for creating a 
sparse backup of just files that have changed from an earlier backup.
</dd><dt>Beginning in version 2.6.4, multiple <b>--compare-dest</b> directories may be
</dt><dd>provided, which will cause rsync to search the list in the 
order specified for an exact match. If a match is found that differs 
only in attributes, a local
copy is made and the attributes updated. If a match is not found, a 
basis file from one of the <i>DIR</i>s will be selected to try to speed up the transfer.
</dd><dt>If <i>DIR</i> is a relative path, it is relative to the destination directory.
</dt><dd>See also <b>--copy-dest</b> and <b>--link-dest</b>.
</dd><dt><b>--copy-dest=DIR</b>
</dt><dd>This option behaves like <b>--compare-dest</b>, but rsync will also copy unchanged files found in <i>DIR</i>
 to the destination directory using a local
copy. This is useful for doing transfers to a new destination while 
leaving existing files intact, and then doing a flash-cutover when all 
files have been
successfully transferred.
</dd><dt>Multiple <b>--copy-dest</b> directories may be provided, which will cause
</dt><dd>rsync to search the list in the order specified for an unchanged file. If a match is not found, a basis file from one of the <i>DIR</i>s will be selected
to try to speed up the transfer.
</dd><dt>If <i>DIR</i> is a relative path, it is relative to the destination directory.
</dt><dd>See also <b>--compare-dest</b> and <b>--link-dest</b>.
</dd><dt><b>--link-dest=DIR</b>
</dt><dd>This option behaves like <b>--copy-dest</b>, but unchanged files are hard linked from <i>DIR</i> to the destination directory. The files must be identical
in all preserved attributes (e.g. permissions, possibly ownership) in order for the files to be linked together. An example:
</dd><dt>CW rsync -av --link-dest=$PWD/prior_dir host:src_dir/ new_dir/
</dt><dt>If file's aren't linking, double-check their attributes. Also check if some
</dt><dd>attributes are getting forced outside of rsync's control, such a
 mount option that squishes root to a single user, or mounts a removable
 drive with generic
ownership (such as OS X's lqIgnore ownership on this volumerq option).
</dd><dt>Beginning in version 2.6.4, multiple <b>--link-dest</b> directories may be
</dt><dd>provided, which will cause rsync to search the list in the 
order specified for an exact match. If a match is found that differs 
only in attributes, a local
copy is made and the attributes updated. If a match is not found, a 
basis file from one of the <i>DIR</i>s will be selected to try to speed up the transfer.
</dd><dt>This option works best when copying into an empty destination hierarchy, as
</dt><dd>rsync treats existing files as definitive (so it never looks in
 the link-dest dirs when a destination file already exists), and as 
malleable (so it might
change the attributes of a destination file, which affects all the 
hard-linked versions).
</dd><dt>Note that if you combine this option with <b>--ignore-times</b>, rsync will not
</dt><dd>link any files together because it only links identical files 
together as a substitute for transferring the file, never as an 
additional check after the
file is updated.
</dd><dt>If <i>DIR</i> is a relative path, it is relative to the destination directory.
</dt><dd>See also <b>--compare-dest</b> and <b>--copy-dest</b>.
</dd><dt>Note that rsync versions prior to 2.6.1 had a bug that could prevent
</dt><dd><b>--link-dest</b> from working properly for a non-super-user when <b>-o</b> was specified (or implied by <b>-a</b>). You can work-around this bug by
avoiding the <b>-o</b> option when sending to an old rsync.
</dd><dt><b>-z, --compress</b>
</dt><dd>With this option, rsync compresses the file data as it is sent 
to the destination machine, which reduces the amount of data being 
transmitted -- something
that is useful over a slow connection.
</dd><dt>Note that this option typically achieves better compression ratios than can
</dt><dd>be achieved by using a compressing remote shell or a 
compressing transport because it takes advantage of the implicit 
information in the matching data
blocks that are not explicitly sent over the connection.
</dd><dt>See the <b>--skip-compress</b> option for the default list of file suffixes
</dt><dd>that will not be compressed.
</dd><dt><b>--compress-level=NUM</b>
</dt><dd>Explicitly set the compression level to use (see <b>--compress</b>) instead of letting it default. If NUM is non-zero, the <b>--compress</b> option is
implied.
</dd><dt><b>--skip-compress=LIST</b>
</dt><dd>Override the list of file suffixes that will not be compressed. The <b>LIST</b> should be one or more file suffixes (without the dot) separated by slashes
(/).
</dd><dt>You may specify an empty string to indicate that no file should be skipped.
</dt><dt>Simple character-class matching is supported: each must consist of a list
</dt><dd>of letters inside the square brackets (e.g. no special classes, such as lq[:alpha:]rq, are supported).
</dd><dt>The characters asterisk (*) and question-mark (?) have no special meaning.
</dt><dt>Here's an example that specifies 6 suffixes to skip (since 1 of the 5 rules
</dt><dd>matches 2 suffixes):<br>
</dd><dt>--skip-compress=gz/jpg/mp[34]/7z/bz2
</dt><dt>The default list of suffixes that will not be compressed is this (several
</dt><dd>of these are newly added for 3.0.0):<br>
</dd><dt>gz/zip/z/rpm/deb/iso/bz2/t[gb]z/7z/mp[34]/mov/avi/ogg/jpg/jpeg
</dt><dt>This list will be replaced by your <b>--skip-compress</b> list in all but one
</dt><dd>situation: a copy from a daemon rsync will add your skipped 
suffixes to its list of non-compressing files (and its list may be 
configured to a different
default).
</dd><dt><b>--numeric-ids</b>
</dt><dd>With this option rsync will transfer numeric group and user IDs
 rather than using user and group names and mapping them at both ends.
</dd><dt>By default rsync will use the username and groupname to determine
</dt><dd>what ownership to give files. The special uid 0 and the special group 0 are never mapped via user/group names even if the <b>--numeric-ids</b> option is
not specified.
</dd><dt>If a user or group has no name on the source system or it has no match
</dt><dd>on the destination system, then the numeric ID from the source 
system is used instead. See also the comments on the lquse chrootrq 
setting in the
rsyncd.conf manpage for information on how the chroot setting affects 
rsync's ability to look up the names of the users and groups and what 
you can do about
it.
</dd><dt><b>--timeout=TIMEOUT</b>
</dt><dd>This option allows you to set a maximum I/O timeout in seconds.
 If no data is transferred for the specified time then rsync will exit. 
The default is 0,
which means no timeout.
</dd><dt><b>--contimeout</b>
</dt><dd>This option allows you to set the amount of time that rsync 
will wait for its connection to an rsync daemon to succeed. If the 
timeout is reached, rsync
exits with an error.
</dd><dt><b>--address</b>
</dt><dd>By default rsync will bind to the wildcard address when connecting to an rsync daemon. The <b>--address</b> option allows you to specify a specific IP
address (or hostname) to bind to. See also this option in the <b>--daemon</b> mode section.
</dd><dt><b>--port=PORT</b>
</dt><dd>This specifies an alternate TCP port number to use rather than 
the default of 873. This is only needed if you are using the 
double-colon (::) syntax to
connect with an rsync daemon (since the URL syntax has a way to specify 
the port as a part of the URL). See also this option in the <b>--daemon</b> mode
section.
</dd><dt><b>--sockopts</b>
</dt><dd>This option can provide endless fun for people who like to tune
 their systems to the utmost degree. You can set all sorts of socket 
options which may make
transfers faster (or slower!). Read the man page for the CWsetsockopt() 
system call for details on some of the options you may be able to set. 
By default no
special socket options are set. This only affects direct socket 
connections to a remote rsync daemon. This option also exists in the <b>--daemon</b> mode
section.
</dd><dt><b>--blocking-io</b>
</dt><dd>This tells rsync to use blocking I/O when launching a remote 
shell transport. If the remote shell is either rsh or remsh, rsync 
defaults to using blocking
I/O, otherwise it defaults to using non-blocking I/O. (Note that ssh 
prefers non-blocking I/O.)
</dd><dt><b>-i, --itemize-changes</b>
</dt><dd>Requests a simple itemized list of the changes that are being 
made to each file, including attribute changes. This is exactly the same
 as specifying
<b>--out-format='%i %n%L'</b>. If you repeat the option, unchanged files will also be output, but only if the receiving rsync is at least version 2.6.7 (you
can use <b>-vv</b> with older versions of rsync, but that also turns on the output of other verbose messages).
</dd><dt>The lq%irq escape has a cryptic output that is 11 letters long. The general
</dt><dd>format is like the string <b>YXcstpoguax</b>, where <b>Y</b> is replaced by the type of update being done, <b>X</b> is replaced by the file-type, and the
other letters represent attributes that may be output if they are being modified.
</dd><dt>The update types that replace the <b>Y</b> are as follows:
</dt><dt>o
</dt><dd>A <b>&lt;</b> means that a file is being transferred to the remote host (sent).
</dd><dt>o
</dt><dd>A <b>&gt;</b> means that a file is being transferred to the local host (received).
</dd><dt>o
</dt><dd>A <b>c</b> means that a local change/creation is occurring for 
the item (such as the creation of a directory or the changing of a 
symlink, etc.).
</dd><dt>o
</dt><dd>A <b>h</b> means that the item is a hard link to another item (requires <b>--hard-links</b>).
</dd><dt>o
</dt><dd>A <b>.</b> means that the item is not being updated (though it might have attributes that are being modified).
</dd><dt>o
</dt><dd>A <b>*</b> means that the rest of the itemized-output area contains a message (e.g. lqdeletingrq).
</dd><dt>The file-types that replace the <b>X</b> are: <b>f</b> for a file, a <b>d</b> for a
</dt><dd>directory, an <b>L</b> for a symlink, a <b>D</b> for a device, and a <b>S</b> for a special file (e.g. named sockets and fifos).
</dd><dt>The other letters in the string above are the actual letters that
</dt><dd>will be output if the associated attribute for the item is 
being updated or a lq.rq for no change. Three exceptions to this are: 
(1) a newly created item
replaces each letter with a lq+rq, (2) an identical item replaces the 
dots with spaces, <i>and (3)</i> an unknown attribute replaces each letter with a lq?rq
(this can happen when talking to an older rsync).
</dd><dt>The attribute that is associated with each letter is as follows:
</dt><dt>o
</dt><dd>A <b>c</b> means either that a regular file has a different checksum (requires <b>--checksum</b>)
 or that a symlink, device, or special file has a changed
value. Note that if you are sending files to an rsync prior to 3.0.1, 
this change flag will be present only for checksum-differing regular 
files.
</dd><dt>o
</dt><dd>A <b>s</b> means the size of a regular file is different and will be updated by the file transfer.
</dd><dt>o
</dt><dd>A <b>t</b> means the modification time is different and is being updated to the sender's value (requires <b>--times</b>). An alternate value of <b>T</b>
means that the modification time will be set to the transfer time, which happens when a file/symlink/device is updated without <b>--times</b> and when a
symlink is changed and the receiver can't set its time. (Note: when using an rsync 3.0.0 client, you might see the <b>s</b> flag combined with <b>t</b> instead
of the proper <b>T</b> flag for this time-setting failure.)
</dd><dt>o
</dt><dd>A <b>p</b> means the permissions are different and are being updated to the sender's value (requires <b>--perms</b>).
</dd><dt>o
</dt><dd>An <b>o</b> means the owner is different and is being updated to the sender's value (requires <b>--owner</b> and super-user privileges).
</dd><dt>o
</dt><dd>A <b>g</b> means the group is different and is being updated to the sender's value (requires <b>--group</b> and the authority to set the group).
</dd><dt>o
</dt><dd>The <b>u</b> slot is reserved for future use.
</dd><dt>o
</dt><dd>The <b>a</b> means that the ACL information changed.
</dd><dt>o
</dt><dd>The <b>x</b> means that the extended attribute information changed.
</dd><dt>One other output is possible: when deleting files, the lq%irq will output
</dt><dd>the string lq*deletingrq for each item that is being removed 
(assuming that you are talking to a recent enough rsync that it logs 
deletions instead of
outputting them as a verbose message).
</dd><dt><b>--out-format=FORMAT</b>
</dt><dd>This allows you to specify exactly what the rsync client 
outputs to the user on a per-update basis. The format is a text string 
containing embedded
single-character escape sequences prefixed with a percent (%) character.
 A default format of lq%n%Lrq is assumed if <b>-v</b> is specified 
(which reports the
name of the file and, if the item is a link, where it points). For a 
full list of the possible escape characters, see the lqlog formatrq 
setting in the
rsyncd.conf manpage.
</dd><dt>Specifying the <b>--out-format</b> option
</dt><dd>will mention each file, dir, etc. that gets updated in a 
significant way (a transferred file, a recreated symlink/device, or a 
touched directory). In
addition, if the itemize-changes escape (%i) is included in the string 
(e.g. if the <b>--itemize-changes</b> option was used), the logging of names increases
to mention any item that is changed in any way (as long as the receiving side is at least 2.6.4). See the <b>--itemize-changes</b> option for a description of
the output of lq%irq.
</dd><dt>Rsync will output the out-format string prior to a file's transfer unless
</dt><dd>one of the transfer-statistic escapes is requested, in which 
case the logging is done at the end of the file's transfer. When this 
late logging is in
effect and <b>--progress</b> is also specified, rsync will also output 
the name of the file being transferred prior to its progress information
 (followed, of
course, by the out-format output).
</dd><dt><b>--log-file=FILE</b>
</dt><dd>This option causes rsync to log what it is doing to a file. 
This is similar to the logging that a daemon does, but can be requested 
for the client side
and/or the server side of a non-daemon transfer. If specified as a 
client option, transfer logging will be enabled with a default format of
 lq%i %n%Lrq. See
the <b>--log-file-format</b> option if you wish to override this.
</dd><dt>Here's a example command that requests the remote side to log what is
</dt><dd>happening:<br>
</dd><dt>rsync -av --rsync-path="rsync --log-file=/tmp/rlog" src/ dest/
</dt><dt>This is very useful if you need to debug why a connection is closing
</dt><dd>unexpectedly.
</dd><dt><b>--log-file-format=FORMAT</b>
</dt><dd>This allows you to specify exactly what per-update logging is put into the file specified by the <b>--log-file</b>
 option (which must also be specified for
this option to have any effect). If you specify an empty string, updated
 files will not be mentioned in the log file. For a list of the possible
 escape
characters, see the lqlog formatrq setting in the rsyncd.conf manpage.
</dd><dt>The default FORMAT used if <b>--log-file</b> is specified and this option is not
</dt><dd>is '%i %n%L'.
</dd><dt><b>--stats</b>
</dt><dd>This tells rsync to print a verbose set of statistics on the 
file transfer, allowing you to tell how effective rsync's delta-transfer
 algorithm is for your
data.
</dd><dt>The current statistics are as follows:
</dt><dt>o
</dt><dd><b>Number of files</b> is the count of all lqfilesrq (in the generic sense), which includes directories, symlinks, etc.
</dd><dt>o
</dt><dd><b>Number of files transferred</b> is the count of normal files that were updated via rsync's delta-transfer algorithm, which does not include created
dirs, symlinks, etc.
</dd><dt>o
</dt><dd><b>Total file size</b> is the total sum of all file sizes in 
the transfer. This does not count any size for directories or special 
files, but does include
the size of symlinks.
</dd><dt>o
</dt><dd><b>Total transferred file size</b> is the total sum of all files sizes for just the transferred files.
</dd><dt>o
</dt><dd><b>Literal data</b> is how much unmatched file-update data we had to send to the receiver for it to recreate the updated files.
</dd><dt>o
</dt><dd><b>Matched data</b> is how much data the receiver got locally when recreating the updated files.
</dd><dt>o
</dt><dd><b>File list size</b> is how big the file-list data was when 
the sender sent it to the receiver. This is smaller than the in-memory 
size for the file list
due to some compressing of duplicated data when rsync sends the list.
</dd><dt>o
</dt><dd><b>File list generation time</b> is the number of seconds that the sender spent creating the file list. This requires a modern rsync on the sending side
for this to be present.
</dd><dt>o
</dt><dd><b>File list transfer time</b> is the number of seconds that the sender spent sending the file list to the receiver.
</dd><dt>o
</dt><dd><b>Total bytes sent</b> is the count of all the bytes that rsync sent from the client side to the server side.
</dd><dt>o
</dt><dd><b>Total bytes received</b> is the count of all non-message bytes that rsync received by the client side from the server side. lqNon-messagerq bytes means
that we don't count the bytes for a verbose message that the server sent to us, which makes the stats more consistent.
</dd><dt><b>-8, --8-bit-output</b>
</dt><dd>This tells rsync to leave all high-bit characters unescaped in 
the output instead of trying to test them to see if they're valid in the
 current locale and
escaping the invalid ones. All control characters (but never tabs) are 
always escaped, regardless of this option's setting.
</dd><dt>The escape idiom that started in 2.6.7 is to output a literal backslash (\)
</dt><dd>and a hash (#), followed by exactly 3 octal digits. For 
example, a newline would output as lq\#012rq. A literal backslash that 
is in a filename is not
escaped unless it is followed by a hash and 3 digits (0-9).
</dd><dt><b>-h, --human-readable</b>
</dt><dd>Output numbers in a more human-readable format. This makes big 
numbers output using larger units, with a K, M, or G suffix. If this 
option was specified
once, these units are K (1000), M (1000*1000), and G (1000*1000*1000); 
if the option is repeated, the units are powers of 1024 instead of 1000.
</dd><dt><b>--partial</b>
</dt><dd>By default, rsync will delete any partially transferred file if
 the transfer is interrupted. In some circumstances it is more desirable
 to keep partially
transferred files. Using the <b>--partial</b> option tells rsync to keep the partial file which should make a subsequent transfer of the rest of the file much
faster.
</dd><dt><b>--partial-dir=DIR</b>
</dt><dd>A better way to keep partial files than the <b>--partial</b> option is to specify a <i>DIR</i>
 that will be used to hold the partial data (instead of
writing it out to the destination file). On the next transfer, rsync 
will use a file found in this dir as data to speed up the resumption of 
the transfer and
then delete it after it has served its purpose.
</dd><dt>Note that if <b>--whole-file</b> is specified (or implied), any partial-dir
</dt><dd>file that is found for a file that is being updated will simply
 be removed (since rsync is sending files without using rsync's 
delta-transfer algorithm).
</dd><dt>Rsync will create the <i>DIR</i> if it is missing (just the last dir -- not
</dt><dd>the whole path). This makes it easy to use a relative path (such as lq<b>--partial-dir=.rsync-partial</b>rq) to have rsync create the partial-directory in
the destination file's directory when needed, and then remove it again when the partial file is deleted.
</dd><dt>If the partial-dir value is not an absolute path, rsync will add an exclude
</dt><dd>rule at the end of all your existing excludes. This will 
prevent the sending of any partial-dir files that may exist on the 
sending side, and will also
prevent the untimely deletion of partial-dir items on the receiving 
side. An example: the above <b>--partial-dir</b> option would add the equivalent of lq<b>-f
'-p .rsync-partial/'</b>rq at the end of any other filter rules.
</dd><dt>If you are supplying your own exclude rules, you may need to add your own
</dt><dd>exclude/hide/protect rule for the partial-dir <i>because (1)</i> the auto-added rule may be ineffective at the end of your other rules, <i>or (2)</i>
 you
may wish to override rsync's exclude choice. For instance, if you want 
to make rsync clean-up any left-over partial-dirs that may be lying 
around, you should
specify <b>--delete-after</b> and add a lqriskrq filter rule, e.g. <b>-f 'R .rsync-partial/'</b>. (Avoid using <b>--delete-before</b> or <b>--delete-during</b>
unless you don't need rsync to use any of the left-over partial-dir data during the current run.)
</dd><dt>IMPORTANT: the <b>--partial-dir</b> should not be writable by other users or it
</dt><dd>is a security risk. E.g. AVOID lq/tmprq.
</dd><dt>You can also set the partial-dir value the RSYNC_PARTIAL_DIR environment
</dt><dd>variable. Setting this in the environment does not force <b>--partial</b> to be enabled, but rather it affects where partial files go when <b>--partial</b>
is specified. For instance, instead of using <b>--partial-dir=.rsync-tmp</b> along with <b>--progress</b>, you could set RSYNC_PARTIAL_DIR=.rsync-tmp in your
environment and then just use the <b>-P</b> option to turn on the use of the .rsync-tmp dir for partial transfers. The only times that the <b>--partial</b>
option does not look for this environment value <i>are (1)</i> when <b>--inplace</b> was specified (since <b>--inplace</b> conflicts with
<b>--partial-dir</b>), <i>and (2)</i> when <b>--delay-updates</b> was specified (see below).
</dd><dt>For the purposes of the daemon-config's lqrefuse optionsrq setting,
</dt><dd><b>--partial-dir</b> does <i>not</i> imply <b>--partial</b>. This is so that a refusal of the <b>--partial</b> option can be used to disallow the
overwriting of destination files with a partial transfer, while still allowing the safer idiom provided by <b>--partial-dir</b>.
</dd><dt><b>--delay-updates</b>
</dt><dd>This option puts the temporary file from each updated file into
 a holding directory until the end of the transfer, at which time all 
the files are renamed
into place in rapid succession. This attempts to make the updating of 
the files a little more atomic. By default the files are placed into a 
directory named
lq.~tmp~rq in each file's destination directory, but if you've specified
 the <b>--partial-dir</b> option, that directory will be used instead. See the comments
in the <b>--partial-dir</b> section for a discussion of how this 
lq.~tmp~rq dir will be excluded from the transfer, and what you can do 
if you want rsync to
cleanup old lq.~tmp~rq dirs that might be lying around. Conflicts with <b>--inplace</b> and <b>--append</b>.
</dd><dt>This option uses more memory on the receiving side (one bit per file
</dt><dd>transferred) and also requires enough free disk space on the 
receiving side to hold an additional copy of all the updated files. Note
 also that you should
not use an absolute path to <b>--partial-dir</b> <i>unless (1)</i> there is no chance of any of the files in the transfer having the same name (since all the
updated files will be put into a single directory if the path is absolute) <i>and (2)</i> there are no mount points in the hierarchy (since the delayed updates
will fail if they can't be renamed into place).
</dd><dt>See also the lqatomic-rsyncrq perl script in the lqsupportrq subdir for an
</dt><dd>update algorithm that is even more atomic (it uses <b>--link-dest</b> and a parallel hierarchy of files).
</dd><dt><b>-m, --prune-empty-dirs</b>
</dt><dd>This option tells the receiving rsync to get rid of empty 
directories from the file-list, including nested directories that have 
no non-directory children.
This is useful for avoiding the creation of a bunch of useless 
directories when the sending rsync is recursively scanning a hierarchy 
of files using
include/exclude/filter rules.
</dd><dt>Note that the use of transfer rules, such as the <b>--min-size</b> option, does
</dt><dd>not affect what goes into the file list, and thus does not 
leave directories empty, even if none of the files in a directory match 
the transfer rule.
</dd><dt>Because the file-list is actually being pruned, this option also affects
</dt><dd>what directories get deleted when a delete is active. However, 
keep in mind that excluded files and directories can prevent existing 
items from being
deleted due to an exclude both hiding source files and protecting 
destination files. See the perishable filter-rule option for how to 
avoid this.
</dd><dt>You can prevent the pruning of certain empty directories from the file-list
</dt><dd>by using a global lqprotectrq filter. For instance, this option
 would ensure that the directory lqemptydirrq was kept in the file-list:
</dd><dt>--filter 'protect emptydir/'
</dt><dt>Here's an example that copies all .pdf files in a hierarchy, only creating
</dt><dd>the necessary destination directories to hold the .pdf files, 
and ensures that any superfluous files and directories in the 
destination are removed (note
the hide filter of non-directories being used instead of an exclude):
</dd><dt>rsync -avm --del --include='*.pdf' -f 'hide,! */' src/ dest
</dt><dt>If you didn't want to remove superfluous destination files, the more
</dt><dd>time-honored options of lq<b>--include='*/' --exclude='*'</b>rq would work fine in place of the hide-filter (if that is more natural to you).
</dd><dt><b>--progress</b>
</dt><dd>This option tells rsync to print information showing the 
progress of the transfer. This gives a bored user something to watch. 
Implies <b>--verbose</b> if
it wasn't already specified.
</dd><dt>While rsync is transferring a regular file, it updates a progress line that
</dt><dd>looks like this:<br>
</dd><dt>782448 63% 110.64kB/s 0:00:04
</dt><dt>In this example, the receiver has reconstructed 782448 bytes or 63% of the
</dt><dd>sender's file, which is being reconstructed at a rate of 110.64
 kilobytes per second, and the transfer will finish in 4 seconds if the 
current rate is
maintained until the end.
</dd><dt>These statistics can be misleading if rsync's delta-transfer algorithm is
</dt><dd>in use. For example, if the sender's file consists of the basis
 file followed by additional data, the reported rate will probably drop 
dramatically when
the receiver gets to the literal data, and the transfer will probably 
take much longer to finish than the receiver estimated as it was 
finishing the matched
part of the file.
</dd><dt>When the file transfer finishes, rsync replaces the progress line with a
</dt><dd>summary line that looks like this:<br>
</dd><dt>1238099 100% 146.38kB/s 0:00:08 (xfer#5, to-check=169/396)
</dt><dt>In this example, the file was 1238099 bytes long in total, the average rate
</dt><dd>of transfer for the whole file was 146.38 kilobytes per second 
over the 8 seconds that it took to complete, it was the 5th transfer of a
 regular file
during the current rsync session, and there are 169 more files for the 
receiver to check (to see if they are up-to-date or not) remaining out 
of the 396 total
files in the file-list.
</dd><dt><b>-P</b>
</dt><dd>The <b>-P</b> option is equivalent to <b>--partial --progress</b>. Its purpose is to make it much easier to specify these two options for a long
transfer that may be interrupted.
</dd><dt><b>--password-file</b>
</dt><dd>This option allows you to provide a password in a file for 
accessing an rsync daemon. The file must not be world readable. It 
should contain just the
password as a single line.
</dd><dt>This option does not supply a password to a remote shell transport such as
</dt><dd>ssh; to learn how to do that, consult the remote shell's 
documentation. When accessing an rsync daemon using a remote shell as 
the transport, this option
only comes into effect after the remote shell finishes its 
authentication (i.e. if you have also specified a password in the 
daemon's config file).
</dd><dt><b>--list-only</b>
</dt><dd>This option will cause the source files to be listed instead of
 transferred. This option is inferred if there is a single source arg 
and no destination
specified, so its main uses are: (1) to turn a copy command that 
includes a destination arg into a file-listing command, <i>or (2)</i> to
 be able to specify
more than one source arg (note: be sure to include the destination). 
Caution: keep in mind that a source arg with a wild-card is expanded by 
the shell into
multiple args, so it is never safe to try to list such an arg without 
using this option. For example:<br>
</dd><dt>rsync -av --list-only foo* dest/
</dt><dt>Compatibility note: when requesting a remote listing of files from an rsync
</dt><dd>that is version 2.6.3 or older, you may encounter an error if 
you ask for a non-recursive listing. This is because a file listing 
implies the <b>--dirs</b>
option w/o <b>--recursive</b>, and older rsyncs don't have that option. To avoid this problem, either specify the <b>--no-dirs</b> option (if you don't need to
expand a directory's content), or turn on recursion and exclude the content of subdirectories: <b>-r --exclude='/*/*'</b>.
</dd><dt><b>--bwlimit=KBPS</b>
</dt><dd>This option allows you to specify a maximum transfer rate in 
kilobytes per second. This option is most effective when using rsync 
with large files (several
megabytes and up). Due to the nature of rsync transfers, blocks of data 
are sent, then if rsync determines the transfer was too fast, it will 
wait before
sending the next data block. The result is an average transfer rate 
equaling the specified limit. A value of zero specifies no limit.
</dd><dt><b>--write-batch=FILE</b>
</dt><dd>Record a file that can later be applied to another identical destination with <b>--read-batch</b>. See the lqBATCH MODErq section for details, and also the
<b>--only-write-batch</b> option.
</dd><dt><b>--only-write-batch=FILE</b>
</dt><dd>Works like <b>--write-batch</b>, except that no updates are made on the destination system when creating the batch. This lets you transport the changes to
the destination system via some other means and then apply the changes via <b>--read-batch</b>.
</dd><dt>Note that you can feel free to write the batch directly to some portable
</dt><dd>media: if this media fills to capacity before the end of the 
transfer, you can just apply that partial transfer to the destination 
and repeat the whole
process to get the rest of the changes (as long as you don't mind a 
partially updated destination system while the multi-update cycle is 
happening).
</dd><dt>Also note that you only save bandwidth when pushing changes to a remote
</dt><dd>system because this allows the batched data to be diverted from
 the sender into the batch file without having to flow over the wire to 
the receiver (when
pulling, the sender is remote, and thus can't write the batch).
</dd><dt><b>--read-batch=FILE</b>
</dt><dd>Apply all of the changes stored in FILE, a file previously generated by <b>--write-batch</b>. If <i>FILE</i> is <b>-</b>, the batch data will be read from
standard input. See the lqBATCH MODErq section for details.
</dd><dt><b>--protocol=NUM</b>
</dt><dd>Force an older protocol version to be used. This is useful for 
creating a batch file that is compatible with an older version of rsync.
 For instance, if
rsync 2.6.4 is being used with the <b>--write-batch</b> option, but rsync 2.6.3 is what will be used to run the <b>--read-batch</b>
 option, you should use
lq--protocol=28rq when creating the batch file to force the older 
protocol version to be used in the batch file (assuming you can't 
upgrade the rsync on the
reading system).
</dd><dt><b>--iconv=CONVERT_SPEC</b>
</dt><dd>Rsync can convert filenames between character sets using this 
option. Using a CONVERT_SPEC of lq.rq tells rsync to look up the default
 character-set via
the locale setting. Alternately, you can fully specify what conversion 
to do by giving a local and a remote charset separated by a comma in the
 order
<b>--iconv=LOCAL,REMOTE</b>, e.g. <b>--iconv=utf8,iso88591</b>. This order ensures that the option will stay the same whether you're pushing or pulling files.
Finally, you can specify either <b>--no-iconv</b> or a CONVERT_SPEC of lq-rq to turn off any conversion. The default setting of this option is site-specific,
and can also be affected via the RSYNC_ICONV environment variable.
</dd><dt>For a list of what charset names your local iconv library supports, you can
</dt><dd>run lqiconv --listrq.
</dd><dt>If you specify the <b>--protect-args</b> option (<b>-s</b>), rsync will translate
</dt><dd>the filenames you specify on the command-line that are being sent to the remote host. See also the <b>--files-from</b> option.
</dd><dt>Note that rsync does not do any conversion of names in filter files
</dt><dd>(including include/exclude files). It is up to you to ensure 
that you're specifying matching rules that can match on both sides of 
the transfer. For
instance, you can specify extra include/exclude rules if there are 
filename differences on the two sides that need to be accounted for.
</dd><dt>When you pass an <b>--iconv</b> option to an rsync daemon that allows it, the
</dt><dd>daemon uses the charset specified in its lqcharsetrq 
configuration parameter regardless of the remote charset you actually 
pass. Thus, you may feel free to
specify just the local charset for a daemon transfer (e.g. <b>--iconv=utf8</b>).
</dd><dt><b>-4, --ipv4</b> or <b>-6, --ipv6</b>
</dt><dd>Tells rsync to prefer IPv4/IPv6 when creating sockets. This 
only affects sockets that rsync has direct control over, such as the 
outgoing socket when
directly contacting an rsync daemon. See also these options in the <b>--daemon</b> mode section.
</dd><dt>If rsync was complied without support for IPv6, the <b>--ipv6</b> option
</dt><dd>will have no effect. The <b>--version</b> output will tell you if this is the case.
</dd><dt><b>--checksum-seed=NUM</b>
</dt><dd>Set the checksum seed to the integer NUM. This 4 byte checksum 
seed is included in each block and file checksum calculation. By default
 the checksum seed
is generated by the server and defaults to the current CWtime() . This 
option is used to set a specific checksum seed, which is useful for 
applications that
want repeatable block and file checksums, or in the case where the user 
wants a more random checksum seed. Setting NUM to 0 causes rsync to use 
the default of
CWtime() for checksum seed.</dd></dl>
<h2>Daemon Options</h2>
<p>The options allowed when starting an rsync daemon are as follows:
</p><dl compact="compact">
<dt><b>--daemon</b>
</dt><dd>This tells rsync that it is to run as a daemon. The daemon you start running may be accessed using an rsync client using the <b>host::module</b> or
<b>rsync://host/module/</b> syntax.
</dd><dt>If standard input is a socket then rsync will assume that it is being
</dt><dd>run via inetd, otherwise it will detach from the current 
terminal and become a background daemon. The daemon will read the config
 file (rsyncd.conf) on
each connect made by a client and respond to requests accordingly. See 
the <i><b><a href="http://linux.die.net/man/5/rsyncd.conf" rel="nofollow">rsyncd.conf</a></b>(5)</i> man page for more details.
</dd><dt><b>--address</b>
</dt><dd>By default rsync will bind to the wildcard address when run as a daemon with the <b>--daemon</b> option. The <b>--address</b> option allows you to specify
a specific IP address (or hostname) to bind to. This makes virtual hosting possible in conjunction with the <b>--config</b> option. See also the lqaddressrq
global option in the rsyncd.conf manpage.
</dd><dt><b>--bwlimit=KBPS</b>
</dt><dd>This option allows you to specify a maximum transfer rate in 
kilobytes per second for the data the daemon sends. The client can still
 specify a smaller
<b>--bwlimit</b> value, but their requested value will be rounded down 
if they try to exceed it. See the client version of this option (above) 
for some extra
details.
</dd><dt><b>--config=FILE</b>
</dt><dd>This specifies an alternate config file than the default. This is only relevant when <b>--daemon</b>
 is specified. The default is /etc/rsyncd.conf unless
the daemon is running over a remote shell program and the remote user is
 not the super-user; in that case the default is rsyncd.conf in the 
current directory
(typically $HOME).
</dd><dt><b>--no-detach</b>
</dt><dd>When running as a daemon, this option instructs rsync to not 
detach itself and become a background process. This option is required 
when running as a
service on Cygwin, and may also be useful when rsync is supervised by a 
program such as <b>daemontools</b> or AIX's <b>System Resource Controller</b>.
<b>--no-detach</b> is also recommended when rsync is run under a debugger. This option has no effect if rsync is run from inetd or sshd.
</dd><dt><b>--port=PORT</b>
</dt><dd>This specifies an alternate TCP port number for the daemon to 
listen on rather than the default of 873. See also the lqportrq global 
option in the
rsyncd.conf manpage.
</dd><dt><b>--log-file=FILE</b>
</dt><dd>This option tells the rsync daemon to use the given log-file name instead of using the lqlog filerq setting in the config file.
</dd><dt><b>--log-file-format=FORMAT</b>
</dt><dd>This option tells the rsync daemon to use the given FORMAT 
string instead of using the lqlog formatrq setting in the config file. 
It also enables
lqtransfer loggingrq unless the string is empty, in which case transfer 
logging is turned off.
</dd><dt><b>--sockopts</b>
</dt><dd>This overrides the <b>socket options</b> setting in the rsyncd.conf file and has the same syntax.
</dd><dt><b>-v, --verbose</b>
</dt><dd>This option increases the amount of information the daemon logs
 during its startup phase. After the client connects, the daemon's 
verbosity level will be
controlled by the options that the client used and the lqmax verbosityrq
 setting in the module's config section.
</dd><dt><b>-4, --ipv4</b> or <b>-6, --ipv6</b>
</dt><dd>Tells rsync to prefer IPv4/IPv6 when creating the incoming 
sockets that the rsync daemon will use to listen for connections. One of
 these options may be
required in older versions of Linux to work around an IPv6 bug in the 
kernel (if you see an lqaddress already in userq error when nothing else
 is using the
port, try specifying <b>--ipv6</b> or <b>--ipv4</b> when starting the daemon).
</dd><dt>If rsync was complied without support for IPv6, the <b>--ipv6</b> option
</dt><dd>will have no effect. The <b>--version</b> output will tell you if this is the case.
</dd><dt><b>-h, --help</b>
</dt><dd>When specified after <b>--daemon</b>, print a short help page describing the options available for starting an rsync daemon.</dd></dl>
<h2>Filter Rules</h2>
<p>The filter rules allow for flexible selection of which files to 
transfer (include) and which files to skip (exclude). The rules either 
directly specify
include/exclude patterns or they specify a way to acquire more 
include/exclude patterns (e.g. to read them from a file).
</p><p>As the list of files/directories to transfer is built, rsync 
checks each name to be transferred against the list of include/exclude 
patterns in turn, and
the first matching pattern is acted on: if it is an exclude pattern, 
then that file is skipped; if it is an include pattern then that 
filename is not skipped;
if no matching pattern is found, then the filename is not skipped.
</p><p>Rsync builds an ordered list of filter rules as specified on the command-line. Filter rules have the following syntax:
</p><blockquote>CWRULE [PATTERN_OR_FILENAME]<br>
CWRULE,MODIFIERS [PATTERN_OR_FILENAME]<br></blockquote>
<p>You have your choice of using either short or long RULE names, as 
described below. If you use a short-named rule, the oq,cq separating the
 RULE from the
MODIFIERS is optional. The PATTERN or FILENAME that follows (when 
present) must come after either a single space or an underscore (_). 
Here are the available
rule prefixes:
</p><blockquote><b>exclude, -</b> specifies an exclude pattern.<br>
<b>include, +</b> specifies an include pattern.<br>
<b>merge, .</b> specifies a merge-file to read for more rules.<br>
<b>dir-merge, :</b> specifies a per-directory merge-file.<br>
<b>hide, H</b> specifies a pattern for hiding files from the transfer.<br>
<b>show, S</b> files that match the pattern are not hidden.<br>
<b>protect, P</b> specifies a pattern for protecting files from deletion.<br>
<b>risk, R</b> files that match the pattern are not protected.<br>
<b>clear, !</b> clears the current include/exclude list (takes no arg)<br></blockquote>
<p>When rules are being read from a file, empty lines are ignored, as are comment lines that start with a lq#rq.
</p><p>Note that the <b>--include</b>/<b>--exclude</b> command-line 
options do not allow the full range of rule parsing as described above 
-- they only allow the
specification of include/exclude patterns plus a lq!rq token to clear 
the list (and the normal comment parsing when rules are read from a 
file). If a pattern
does not begin with lq- rq (dash, space) or lq+ rq (plus, space), then 
the rule will be interpreted as if lq+ rq (for an include option) or lq-
 rq (for an
exclude option) were prefixed to the string. A <b>--filter</b> option, on the other hand, must always contain either a short or long rule name at the start of
the rule.
</p><p>Note also that the <b>--filter</b>, <b>--include</b>, and <b>--exclude</b> options take one rule/pattern each. To add multiple ones, you can repeat the
options on the command-line, use the merge-file syntax of the <b>--filter</b> option, or the <b>--include-from</b>/<b>--exclude-from</b> options.
</p><h2>Include/Exclude Pattern Rules</h2>
<p>You can include and exclude files by specifying patterns using the 
lq+rq, lq-rq, etc. filter rules (as introduced in the FILTER RULES 
section above). The
include/exclude rules each specify a pattern that is matched against the
 names of the files that are going to be transferred. These patterns can
 take several
forms:
</p><dl compact="compact">
<dt>o
</dt><dd>if the pattern starts with a / then it is anchored to a 
particular spot in the hierarchy of files, otherwise it is matched 
against the end of the pathname.
This is similar to a leading ^ in regular expressions. Thus lq/foorq 
would match a name of lqfoorq at either the lqroot of the transferrq 
(for a global rule)
or in the merge-file's directory (for a per-directory rule). An 
unqualified lqfoorq would match a name of lqfoorq anywhere in the tree 
because the algorithm is
applied recursively from the top down; it behaves as if each path 
component gets a turn at being the end of the filename. Even the 
unanchored lqsub/foorq would
match at any point in the hierarchy where a lqfoorq was found within a 
directory named lqsubrq. See the section on ANCHORING INCLUDE/EXCLUDE 
PATTERNS for a
full discussion of how to specify a pattern that matches at the root of 
the transfer.
</dd><dt>o
</dt><dd>if the pattern ends with a / then it will only match a directory, not a regular file, symlink, or device.
</dd><dt>o
</dt><dd>rsync chooses between doing a simple string match and wildcard 
matching by checking if the pattern contains one of these three wildcard
 characters: oq*cq,
oq?cq, and oq[cq .
</dd><dt>o
</dt><dd>a oq*cq matches any path component, but it stops at slashes.
</dd><dt>o
</dt><dd>use '**' to match anything, including slashes.
</dd><dt>o
</dt><dd>a oq?cq matches any character except a slash (/).
</dd><dt>o
</dt><dd>a oq[cq introduces a character class, such as [a-z] or [[:alpha:]].
</dd><dt>o
</dt><dd>in a wildcard pattern, a backslash can be used to escape a 
wildcard character, but it is matched literally when no wildcards are 
present.
</dd><dt>o
</dt><dd>if the pattern contains a / (not counting a trailing /) or a 
lq**rq, then it is matched against the full pathname, including any 
leading directories. If
the pattern doesn't contain a / or a lq**rq, then it is matched only 
against the final component of the filename. (Remember that the 
algorithm is applied
recursively so lqfull filenamerq can actually be any portion of a path 
from the starting directory on down.)
</dd><dt>o
</dt><dd>a trailing lqdir_name/***rq will match both the directory (as 
if lqdir_name/rq had been specified) and everything in the directory (as
 if lqdir_name/**rq
had been specified). This behavior was added in version 2.6.7.</dd></dl>
<p>Note that, when using the <b>--recursive</b> (<b>-r</b>) option (which is implied by <b>-a</b>),
 every subcomponent of every path is visited from the top
down, so include/exclude patterns get applied recursively to each 
subcomponent's full name (e.g. to include lq/foo/bar/bazrq the 
subcomponents lq/foorq and
lq/foo/barrq must not be excluded). The exclude patterns actually 
short-circuit the directory traversal stage when rsync finds the files 
to send. If a pattern
excludes a particular parent directory, it can render a deeper include 
pattern ineffectual because rsync did not descend through that excluded 
section of the
hierarchy. This is particularly important when using a trailing oq*cq 
rule. For instance, this won't work:
</p><blockquote>CW+ /some/path/this-file-will-not-be-found<br>
CW+ /file-is-included<br>
CW- *<br></blockquote>
<p>This fails because the parent directory lqsomerq is excluded by the 
oq*cq rule, so rsync never visits any of the files in the lqsomerq or 
lqsome/pathrq
directories. One solution is to ask for all directories in the hierarchy
 to be included by using a single rule: lq+ */rq (put it somewhere 
before the lq- *rq
rule), and perhaps use the <b>--prune-empty-dirs</b> option. Another solution is to add specific include rules for all the parent dirs that need to be visited.
For instance, this set of rules works fine:
</p><blockquote>CW+ /some/<br>
CW+ /some/path/<br>
CW+ /some/path/this-file-is-found<br>
CW+ /file-also-included<br>
CW- *<br></blockquote>
<p>Here are some examples of exclude/include matching:
</p><dl compact="compact">
<dt>o
</dt><dd>lq- *.orq would exclude all names matching *.o
</dd><dt>o
</dt><dd>lq- /foorq would exclude a file (or directory) named foo in the transfer-root directory
</dd><dt>o
</dt><dd>lq- foo/rq would exclude any directory named foo
</dd><dt>o
</dt><dd>lq- /foo/*/barrq would exclude any file named bar which is at 
two levels below a directory named foo in the transfer-root directory
</dd><dt>o
</dt><dd>lq- /foo/**/barrq would exclude any file named bar two or more levels below a directory named foo in the transfer-root directory
</dd><dt>o
</dt><dd>The combination of lq+ */rq, lq+ *.crq, and lq- *rq would 
include all directories and C source files but nothing else (see also 
the
<b>--prune-empty-dirs</b> option)
</dd><dt>o
</dt><dd>The combination of lq+ foo/rq, lq+ foo/bar.crq, and lq- *rq 
would include only the foo directory and foo/bar.c (the foo directory 
must be explicitly
included or it would be excluded by the lq*rq)</dd></dl>
<p>The following modifiers are accepted after a lq+rq or lq-rq:
</p><dl compact="compact">
<dt>o
</dt><dd>A <b>/</b> specifies that the include/exclude rule should be 
matched against the absolute pathname of the current item. For example, 
lq-/ /etc/passwdrq
would exclude the passwd file any time the transfer was sending files 
from the lq/etcrq directory, and lq-/ subdir/foorq would always exclude 
lqfoorq when it
is in a dir named lqsubdirrq, even if lqfoorq is at the root of the 
current transfer.
</dd><dt>o
</dt><dd>A <b>!</b> specifies that the include/exclude should take 
effect if the pattern fails to match. For instance, lq-! */rq would 
exclude all non-directories.
</dd><dt>o
</dt><dd>A <b>C</b> is used to indicate that all the global CVS-exclude 
rules should be inserted as excludes in place of the lq-Crq. No arg 
should follow.
</dd><dt>o
</dt><dd>An <b>s</b> is used to indicate that the rule applies to the 
sending side. When a rule affects the sending side, it prevents files 
from being transferred.
The default is for a rule to affect both sides unless <b>--delete-excluded</b> was specified, in which case default rules become sender-side only. See also the
hide (H) and show (S) rules, which are an alternate way to specify sending-side includes/excludes.
</dd><dt>o
</dt><dd>An <b>r</b> is used to indicate that the rule applies to the 
receiving side. When a rule affects the receiving side, it prevents 
files from being deleted.
See the <b>s</b> modifier for more info. See also the protect (P) and 
risk (R) rules, which are an alternate way to specify receiver-side 
includes/excludes.
</dd><dt>o
</dt><dd>A <b>p</b> indicates that a rule is perishable, meaning that it is ignored in directories that are being deleted. For instance, the <b>-C</b>
 option's
default rules that exclude things like lqCVSrq and lq*.orq are marked as
 perishable, and will not prevent a directory that was removed on the 
source from being
deleted on the destination.</dd></dl>
<h2>Merge-file Filter Rules</h2>
<p>You can merge whole files into your filter rules by specifying either
 a merge (.) or a dir-merge (:) filter rule (as introduced in the FILTER
 RULES section
above).
</p><p>There are two kinds of merged files -- single-instance (oq.cq) 
and per-directory (oq:cq). A single-instance merge file is read one 
time, and its rules are
incorporated into the filter list in the place of the lq.rq rule. For 
per-directory merge files, rsync will scan every directory that it 
traverses for the
named file, merging its contents when the file exists into the current 
list of inherited rules. These per-directory rule files must be created 
on the sending
side because it is the sending side that is being scanned for the 
available files to transfer. These rule files may also need to be 
transferred to the
receiving side if you want them to affect what files don't get deleted 
(see PER-DIRECTORY RULES AND DELETE below).
</p><p>Some examples:
</p><blockquote>CWmerge /etc/rsync/default.rules<br>
CW. /etc/rsync/default.rules<br>
CWdir-merge .per-dir-filter<br>
CWdir-merge,n- .non-inherited-per-dir-excludes<br>
CW:n- .non-inherited-per-dir-excludes<br></blockquote>
<p>The following modifiers are accepted after a merge or dir-merge rule:
</p><dl compact="compact">
<dt>o
</dt><dd>A <b>-</b> specifies that the file should consist of only exclude patterns, with no other rule-parsing except for in-file comments.
</dd><dt>o
</dt><dd>A <b>+</b> specifies that the file should consist of only include patterns, with no other rule-parsing except for in-file comments.
</dd><dt>o
</dt><dd>A <b>C</b> is a way to specify that the file should be read in a
 CVS-compatible manner. This turns on oqncq, oqwcq, and '-', but also 
allows the
list-clearing token (!) to be specified. If no filename is provided, 
lq.cvsignorerq is assumed.
</dd><dt>o
</dt><dd>A <b>e</b> will exclude the merge-file name from the transfer; e.g. lqdir-merge,e .rulesrq is like lqdir-merge .rulesrq and lq- .rulesrq.
</dd><dt>o
</dt><dd>An <b>n</b> specifies that the rules are not inherited by subdirectories.
</dd><dt>o
</dt><dd>A <b>w</b> specifies that the rules are word-split on 
whitespace instead of the normal line-splitting. This also turns off 
comments. Note: the space that
separates the prefix from the rule is treated specially, so lq- foo + 
barrq is parsed as two rules (assuming that prefix-parsing wasn't also 
disabled).
</dd><dt>o
</dt><dd>You may also specify any of the modifiers for the lq+rq or 
lq-rq rules (above) in order to have the rules that are read in from the
 file default to having
that modifier set. For instance, lqmerge,-/ .exclrq would treat the 
contents of .excl as absolute-path excludes, while lqdir-merge,s .filtrq
 and lq:sCrq would
each make all their per-directory rules apply only on the sending side.</dd></dl>
<p>Per-directory rules are inherited in all subdirectories of the 
directory where the merge-file was found unless the oqncq modifier was 
used. Each
subdirectory's rules are prefixed to the inherited per-directory rules 
from its parents, which gives the newest rules a higher priority than 
the inherited
rules. The entire set of dir-merge rules are grouped together in the 
spot where the merge-file was specified, so it is possible to override 
dir-merge rules via
a rule that got specified earlier in the list of global rules. When the 
list-clearing rule (lq!rq) is read from a per-directory file, it only 
clears the
inherited rules for the current merge file.
</p><p>Another way to prevent a single rule from a dir-merge file from 
being inherited is to anchor it with a leading slash. Anchored rules in a
 per-directory
merge-file are relative to the merge-file's directory, so a pattern 
lq/foorq would only match the file lqfoorq in the directory where the 
dir-merge filter file
was found.
</p><p>Here's an example filter file which you'd specify via <b>--filter=". file":</b>
</p><blockquote>CWmerge /home/user/.global-filter<br>
CW- *.gz<br>
CWdir-merge .rules<br>
CW+ *.[ch]<br>
CW- *.o<br></blockquote>
<p>This will merge the contents of the /home/user/.global-filter file at
 the start of the list and also turns the lq.rulesrq filename into a 
per-directory
filter file. All rules read in prior to the start of the directory scan 
follow the global anchoring rules (i.e. a leading slash matches at the 
root of the
transfer).
</p><p>If a per-directory merge-file is specified with a path that is a 
parent directory of the first transfer directory, rsync will scan all 
the parent dirs from
that starting point to the transfer directory for the indicated 
per-directory file. For instance, here is a common filter (see <b>-F</b>):
</p><blockquote>CW--filter=': /.rsync-filter'</blockquote>
<p>That rule tells rsync to scan for the file .rsync-filter in all 
directories from the root down through the parent directory of the 
transfer prior to the
start of the normal directory scan of the file in the directories that 
are sent as a part of the transfer. (Note: for an rsync daemon, the root
 is always the
same as the module's lqpathrq.)
</p><p>Some examples of this pre-scanning for per-directory files:
</p><blockquote>CWrsync -avF /src/path/ /dest/dir<br>
CWrsync -av --filter=': ../../.rsync-filter' /src/path/ /dest/dir<br>
CWrsync -av --filter=': .rsync-filter' /src/path/ /dest/dir<br></blockquote>
<p>The first two commands above will look for lq.rsync-filterrq in lq/rq
 and lq/srcrq before the normal scan begins looking for the file in 
lq/src/pathrq and
its subdirectories. The last command avoids the parent-dir scan and only
 looks for the lq.rsync-filterrq files in each directory that is a part 
of the
transfer.
</p><p>If you want to include the contents of a lq.cvsignorerq in your 
patterns, you should use the rule lq:Crq, which creates a dir-merge of 
the .cvsignore file,
but parsed in a CVS-compatible manner. You can use this to affect where 
the <b>--cvs-exclude</b> (<b>-C</b>) option's inclusion of the 
per-directory .cvsignore
file gets placed into your rules by putting the lq:Crq wherever you like
 in your filter rules. Without this, rsync would add the dir-merge rule 
for the
.cvsignore file at the end of all your other rules (giving it a lower 
priority than your command-line rules). For example:
</p><blockquote>CWcat &lt;&lt;EOT | rsync -avC --filter='. -' a/ b<br>
CW+ foo.o<br>
CW:C<br>
CW- *.old<br>
CWEOT<br>
CWrsync -avC --include=foo.o -f :C --exclude='*.old' a/ b<br></blockquote>
<p>Both of the above rsync commands are identical. Each one will merge 
all the per-directory .cvsignore rules in the middle of the list rather 
than at the end.
This allows their dir-specific rules to supersede the rules that follow 
the :C instead of being subservient to all your rules. To affect the 
other CVS exclude
rules (i.e. the default list of exclusions, the contents of 
$HOME/.cvsignore, and the value of $CVSIGNORE) you should omit the <b>-C</b> command-line option
and instead insert a lq-Crq rule into your filter rules; e.g. lq<b>--filter=-C</b>rq.
</p><h2>List-clearing Filter Rule</h2>
<p>You can clear the current include/exclude list by using the lq!rq 
filter rule (as introduced in the FILTER RULES section above). The 
lqcurrentrq list is
either the global list of rules (if the rule is encountered while 
parsing the filter options) or a set of per-directory rules (which are 
inherited in their own
sub-list, so a subdirectory can use this to clear out the parent's 
rules).
</p><h2>Anchoring Include/Exclude Patterns</h2>
<p>As mentioned earlier, global include/exclude patterns are anchored at
 the lqroot of the transferrq (as opposed to per-directory patterns, 
which are anchored
at the merge-file's directory). If you think of the transfer as a 
subtree of names that are being sent from sender to receiver, the 
transfer-root is where the
tree starts to be duplicated in the destination directory. This root 
governs where patterns that start with a / match.
</p><p>Because the matching is relative to the transfer-root, changing the trailing slash on a source path or changing your use of the <b>--relative</b>
 option
affects the path you need to use in your matching (in addition to 
changing how much of the file tree is duplicated on the destination 
host). The following
examples demonstrate this.
</p><p>Let's say that we want to match two source files, one with an 
absolute path of lq/home/me/foo/barrq, and one with a path of 
lq/home/you/bar/bazrq. Here is
how the various command choices differ for a 2-source transfer:
</p><blockquote>Example cmd: rsync -a /home/me /home/you /dest<br>
+/- pattern: /me/foo/bar<br>
+/- pattern: /you/bar/baz<br>
Target file: /dest/me/foo/bar<br>
Target file: /dest/you/bar/baz<br></blockquote>
<blockquote>Example cmd: rsync -a /home/me/ /home/you/ /dest<br>
+/- pattern: /foo/bar (note missing lqmerq)<br>
+/- pattern: /bar/baz (note missing lqyourq)<br>
Target file: /dest/foo/bar<br>
Target file: /dest/bar/baz<br></blockquote>
<blockquote>Example cmd: rsync -a --relative /home/me/ /home/you /dest<br>
+/- pattern: /home/me/foo/bar (note full path)<br>
+/- pattern: /home/you/bar/baz (ditto)<br>
Target file: /dest/home/me/foo/bar<br>
Target file: /dest/home/you/bar/baz<br></blockquote>
<blockquote>Example cmd: cd /home; rsync -a --relative me/foo you/ /dest<br>
+/- pattern: /me/foo/bar (starts at specified path)<br>
+/- pattern: /you/bar/baz (ditto)<br>
Target file: /dest/me/foo/bar<br>
Target file: /dest/you/bar/baz<br></blockquote>
<p>The easiest way to see what name you should filter is to just look at the output when using <b>--verbose</b> and put a / in front of the name (use the
<b>--dry-run</b> option if you're not yet ready to copy any files).
</p><h2>Per-directory Rules and Delete</h2>
<p>Without a delete option, per-directory rules are only relevant on the
 sending side, so you can feel free to exclude the merge files 
themselves without
affecting the transfer. To make this easy, the oqecq modifier adds this 
exclude for you, as seen in these two equivalent commands:
</p><blockquote>CWrsync -av --filter=': .excl' --exclude=.excl host:src/dir /dest<br>
CWrsync -av --filter=':e .excl' host:src/dir /dest<br></blockquote>
<p>However, if you want to do a delete on the receiving side AND you 
want some files to be excluded from being deleted, you'll need to be 
sure that the
receiving side knows what files to exclude. The easiest way is to 
include the per-directory merge files in the transfer and use <b>--delete-after</b>, because
this ensures that the receiving side gets all the same exclude rules as the sending side before it tries to delete anything:
</p><blockquote>CWrsync -avF --delete-after host:src/dir /dest</blockquote>
<p>However, if the merge files are not a part of the transfer, you'll 
need to either specify some global exclude rules (i.e. specified on the 
command line), or
you'll need to maintain your own per-directory merge files on the 
receiving side. An example of the first is this (assume that the remote 
.rules files exclude
themselves):
</p><pre class="code">rsync -av --filter=': .rules' --filter='. /my/extra.rules'
   --delete host:src/dir /dest</pre>In the above example the extra.rules
 file can affect both sides of the transfer, but (on the sending side) 
the rules are subservient to the rules merged
from the .rules files because they were specified after the 
per-directory merge rule.
<p>In one final example, the remote side is excluding the .rsync-filter 
files from the transfer, but we want to use our own .rsync-filter files 
to control what
gets deleted on the receiving side. To do this we must specifically 
exclude the per-directory merge files (so that they don't get deleted) 
and then put rules
into the local files to control what else should not get deleted. Like 
one of these commands:
</p><pre class="code">rsync -av --filter=':e /.rsync-filter' --delete \
    host:src/dir /dest
rsync -avFF --delete host:src/dir /dest</pre>
<h2>Batch Mode</h2>
<p>Batch mode can be used to apply the same set of updates to many 
identical systems. Suppose one has a tree which is replicated on a 
number of hosts. Now
suppose some changes have been made to this source tree and those 
changes need to be propagated to the other hosts. In order to do this 
using batch mode, rsync
is run with the write-batch option to apply the changes made to the 
source tree to one of the destination trees. The write-batch option 
causes the rsync client
to store in a lqbatch filerq all the information needed to repeat this 
operation against other, identical destination trees.
</p><p>Generating the batch file once saves having to perform the file 
status, checksum, and data block generation more than once when updating
 multiple
destination trees. Multicast transport protocols can be used to transfer
 the batch update files in parallel to many hosts at once, instead of 
sending the same
data to every host individually.
</p><p>To apply the recorded changes to another destination tree, run 
rsync with the read-batch option, specifying the name of the same batch 
file, and the
destination tree. Rsync updates the destination tree using the 
information stored in the batch file.
</p><p>For your convenience, a script file is also created when the 
write-batch option is used: it will be named the same as the batch file 
with lq.shrq appended.
This script file contains a command-line suitable for updating a 
destination tree using the associated batch file. It can be executed 
using a Bourne (or
Bourne-like) shell, optionally passing in an alternate destination tree 
pathname which is then used instead of the original destination path. 
This is useful
when the destination tree path on the current host differs from the one 
used to create the batch file.
</p><p>Examples:
</p><blockquote>CW$ rsync --write-batch=foo -a host:/source/dir/ /adest/dir/<br>
CW$ scp foo* remote:<br>
CW$ ssh remote ./foo.sh /bdest/dir/<br></blockquote>
<blockquote>CW$ rsync --write-batch=foo -a /source/dir/ /adest/dir/<br>
CW$ ssh remote rsync --read-batch=- -a /bdest/dir/ &lt;foo<br></blockquote>
<p>In these examples, rsync is used to update /adest/dir/ from 
/source/dir/ and the information to repeat this operation is stored in 
lqfoorq and lqfoo.shrq.
The host lqremoterq is then updated with the batched data going into the
 directory /bdest/dir. The differences between the two examples reveals 
some of the
flexibility you have in how you deal with batches:
</p><dl compact="compact">
<dt>o
</dt><dd>The first example shows that the initial copy doesn't have to 
be local -- you can push or pull data to/from a remote host using either
 the remote-shell
syntax or rsync daemon syntax, as desired.
</dd><dt>o
</dt><dd>The first example uses the created lqfoo.shrq file to get the 
right rsync options when running the read-batch command on the remote 
host.
</dd><dt>o
</dt><dd>The second example reads the batch data via standard input so 
that the batch file doesn't need to be copied to the remote machine 
first. This example
avoids the foo.sh script because it needed to use a modified <b>--read-batch</b> option, but you could edit the script file if you wished to make use of it
(just be sure that no other option is trying to use standard input, such as the lq<b>--exclude-from=-</b>rq option).</dd></dl>
<p>Caveats:
</p><p>The read-batch option expects the destination tree that it is 
updating to be identical to the destination tree that was used to create
 the batch update
fileset. When a difference between the destination trees is encountered 
the update might be discarded with a warning (if the file appears to be 
up-to-date
already) or the file-update may be attempted and then, if the file fails
 to verify, the update discarded with an error. This means that it 
should be safe to
re-run a read-batch operation if the command got interrupted. If you 
wish to force the batched-update to always be attempted regardless of 
the file's size and
date, use the <b>-I</b> option (when reading the batch). If an error 
occurs, the destination tree will probably be in a partially updated 
state. In that case,
rsync can be used in its regular (non-batch) mode of operation to fix up
 the destination tree.
</p><p>The rsync version used on all destinations must be at least as 
new as the one used to generate the batch file. Rsync will die with an 
error if the protocol
version in the batch file is too new for the batch-reading rsync to 
handle. See also the <b>--protocol</b> option for a way to have the 
creating rsync generate
a batch file that an older rsync can understand. (Note that batch files 
changed format in version 2.6.3, so mixing versions older than that with
 newer versions
will not work.)
</p><p>When reading a batch file, rsync will force the value of certain 
options to match the data in the batch file if you didn't set them to 
the same as the
batch-writing command. Other options can (and should) be changed. For 
instance <b>--write-batch</b> changes to <b>--read-batch</b>, <b>--files-from</b> is
dropped, and the <b>--filter</b>/<b>--include</b>/<b>--exclude</b> options are not needed unless one of the <b>--delete</b> options is specified.
</p><p>The code that creates the BATCH.sh file transforms any 
filter/include/exclude options into a single list that is appended as a 
lqhererq document to the
shell script file. An advanced user can use this to modify the exclude 
list if a change in what gets deleted by <b>--delete</b> is desired. A normal user can
ignore this detail and just use the shell script as an easy way to run the appropriate <b>--read-batch</b> command for the batched data.
</p><p>The original batch mode in rsync was based on lqrsync+rq, but the latest version uses a new implementation.
</p><h2>Symbolic Links</h2>
<p>Three basic behaviors are possible when rsync encounters a symbolic link in the source directory.
</p><p>By default, symbolic links are not transferred at all. A message 
lqskipping non-regularrq file is emitted for any symlinks that exist.
</p><p>If <b>--links</b> is specified, then symlinks are recreated with the same target on the destination. Note that <b>--archive</b> implies <b>--links</b>.
</p><p>If <b>--copy-links</b> is specified, then symlinks are lqcollapsedrq by copying their referent, rather than the symlink.
</p><p>rsync also distinguishes lqsaferq and lqunsaferq symbolic links. 
An example where this might be used is a web site mirror that wishes 
ensure the rsync
module they copy does not include symbolic links to <b>/etc/passwd</b> in the public section of the site. Using <b>--copy-unsafe-links</b> will cause any links
to be copied as the file they point to on the destination. Using <b>--safe-links</b> will cause unsafe links to be omitted altogether. (Note that you must
specify <b>--links</b> for <b>--safe-links</b> to have any effect.)
</p><p>Symbolic links are considered unsafe if they are absolute symlinks (start with <b>/</b>), empty, or if they contain enough lq..rq components to ascend from
the directory being copied.
</p><p>Here's a summary of how the symlink options are interpreted. The 
list is in order of precedence, so if your combination of options isn't 
mentioned, use the
first line that is a complete subset of your options:
</p><dl compact="compact">
<dt><b>--copy-links</b>
</dt><dd>Turn all symlinks into normal files (leaving no symlinks for any other options to affect).
</dd><dt><b>--links --copy-unsafe-links</b>
</dt><dd>Turn all unsafe symlinks into files and duplicate all safe symlinks.
</dd><dt><b>--copy-unsafe-links</b>
</dt><dd>Turn all unsafe symlinks into files, noisily skip all safe symlinks.
</dd><dt><b>--links --safe-links</b>
</dt><dd>Duplicate safe symlinks and skip unsafe ones.
</dd><dt><b>--links</b>
</dt><dd>Duplicate all symlinks.</dd></dl>
<h2>Diagnostics</h2>
<p>rsync occasionally produces error messages that may seem a little 
cryptic. The one that seems to cause the most confusion is lqprotocol 
version mismatch --
is your shell clean?rq.
</p><p>This message is usually caused by your startup scripts or remote 
shell facility producing unwanted garbage on the stream that rsync is 
using for its
transport. The way to diagnose this problem is to run your remote shell 
like this:
</p><blockquote>CWssh remotehost /bin/true &gt; out.dat</blockquote>
<p>then look at out.dat. If everything is working correctly then out.dat
 should be a zero length file. If you are getting the above error from 
rsync then you
will probably find that out.dat contains some text or data. Look at the 
contents and try to work out what is producing it. The most common cause
 is incorrectly
configured shell startup scripts (such as .cshrc or .profile) that 
contain output statements for non-interactive logins.
</p><p>If you are having trouble debugging filter patterns, then try specifying the <b>-vv</b> option. At this level of verbosity rsync will show why each
individual file is included or excluded.
</p><h2>Exit Values</h2>
<dl compact="compact">
<dt><b>0</b>
</dt><dd>Success
</dd><dt><b>1</b>
</dt><dd>Syntax or usage error
</dd><dt><b>2</b>
</dt><dd>Protocol incompatibility
</dd><dt><b>3</b>
</dt><dd>Errors selecting input/output files, dirs
</dd><dt><b>4</b>
</dt><dd>Requested action not supported: an attempt was made to 
manipulate 64-bit files on a platform that cannot support them; or an 
option was specified that is
supported by the client and not by the server.
</dd><dt><b>5</b>
</dt><dd>Error starting client-server protocol
</dd><dt><b>6</b>
</dt><dd>Daemon unable to append to log-file
</dd><dt><b>10</b>
</dt><dd>Error in socket I/O
</dd><dt><b>11</b>
</dt><dd>Error in file I/O
</dd><dt><b>12</b>
</dt><dd>Error in rsync protocol data stream
</dd><dt><b>13</b>
</dt><dd>Errors with program diagnostics
</dd><dt><b>14</b>
</dt><dd>Error in IPC code
</dd><dt><b>20</b>
</dt><dd>Received SIGUSR1 or SIGINT
</dd><dt><b>21</b>
</dt><dd>Some error returned by CWwaitpid()
</dd><dt><b>22</b>
</dt><dd>Error allocating core memory buffers
</dd><dt><b>23</b>
</dt><dd>Partial transfer due to error
</dd><dt><b>24</b>
</dt><dd>Partial transfer due to vanished source files
</dd><dt><b>25</b>
</dt><dd>The --max-delete limit stopped deletions
</dd><dt><b>30</b>
</dt><dd>Timeout in data send/receive
</dd><dt><b>35</b>
</dt><dd>Timeout waiting for daemon connection</dd></dl>
<h2>Environment Variables</h2>
<dl compact="compact">
<dt><b>CVSIGNORE</b>
</dt><dd>The CVSIGNORE environment variable supplements any ignore patterns in .cvsignore files. See the <b>--cvs-exclude</b> option for more details.
</dd><dt><b>RSYNC_ICONV</b>
</dt><dd>Specify a default <b>--iconv</b> setting using this environment variable.
</dd><dt><b>RSYNC_RSH</b>
</dt><dd>The RSYNC_RSH environment variable allows you to override the 
default shell used as the transport for rsync. Command line options are 
permitted after the
command name, just as in the <b>-e</b> option.
</dd><dt><b>RSYNC_PROXY</b>
</dt><dd>The RSYNC_PROXY environment variable allows you to redirect 
your rsync client to use a web proxy when connecting to a rsync daemon. 
You should set
RSYNC_PROXY to a hostname:port pair.
</dd><dt><b>RSYNC_PASSWORD</b>
</dt><dd>Setting RSYNC_PASSWORD to the required password allows you to 
run authenticated rsync connections to an rsync daemon without user 
intervention. Note that
this does not supply a password to a remote shell transport such as ssh;
 to learn how to do that, consult the remote shell's documentation.
</dd><dt><b>USER</b> or <b>LOGNAME</b>
</dt><dd>The USER or LOGNAME environment variables are used to determine
 the default username sent to an rsync daemon. If neither is set, the 
username defaults to
lqnobodyrq.
</dd><dt><b>HOME</b>
</dt><dd>The HOME environment variable is used to find the user's default .cvsignore file.</dd></dl>
<h2>Files</h2>
<p>/etc/rsyncd.conf or rsyncd.conf
</p><h2>See Also</h2>
<p><i><b><a href="http://linux.die.net/man/5/rsyncd.conf" rel="nofollow">rsyncd.conf</a></b>(5)</i>
</p><h2>Bugs</h2>
<p>times are transferred as *nix time_t values
</p><p>When transferring to FAT filesystems rsync may re-sync unmodified files. See the comments on the <b>--modify-window</b> option.
</p><p>file permissions, devices, etc. are transferred as native numerical values
</p><p>see also the comments on the <b>--delete</b> option
</p><p>Please report bugs! See the web site at <a href="http://rsync.samba.org/">http://rsync.samba.org/</a>
</p><h2>Version</h2>
<p>This man page is current for version 3.0.6 of rsync.
</p><h2>Internal Options</h2>
<p>The options <b>--server</b> and <b>--sender</b> are used internally 
by rsync, and should never be typed by a user under normal 
circumstances. Some awareness
of these options may be needed in certain scenarios, such as when 
setting up a login that can only run an rsync command. For instance, the
 support directory of
the rsync distribution has an example script named rrsync (for 
restricted rsync) that can be used with a restricted ssh login.
</p><h2>Credits</h2>
<p>rsync is distributed under the GNU public license. See the file COPYING for details.
</p><p>A WEB site is available at <a href="http://rsync.samba.org/">http://rsync.samba.org/</a>. The site includes an FAQ-O-Matic which may cover questions unanswered by this manual page.
</p><p>The primary ftp site for rsync is <a href="ftp://rsync.samba.org/pub/rsync">ftp://rsync.samba.org/pub/rsync</a>.
</p><p>We would be delighted to hear from you if you like this program. Please contact the mailing-list at <a href="mailto:rsync@lists.samba.org">rsync@lists.samba.org</a>.
</p><p>This program uses the excellent zlib compression library written by Jean-loup Gailly and Mark Adler.
</p><h2>Thanks</h2>
<p>Especial thanks go out to: John Van Essen, Matt McCutchen, Wesley W. 
Terpstra, David Dykstra, Jos Backus, Sebastian Krahmer, Martin Pool, and
 our
gone-but-not-forgotten compadre, J.W. Schultz.
</p><p>Thanks also to Richard Brent, Brendan Mackay, Bill Waite, Stephen
 Rothwell and David Bell. I've probably missed some people, my apologies
 if I have.
</p><h2>Author</h2>
<p>rsync was originally written by Andrew Tridgell and Paul Mackerras. 
Many people have later contributed to it. It is currently maintained by 
Wayne Davison.
</p><p>Mailing lists for support and development are available at <a href="http://lists.samba.org/">http://lists.samba.org</a>

<!-- google_ad_section_end -->
</p><h2>Referenced By</h2>
<b><a href="http://linux.die.net/man/1/fakeroot-tcp" rel="nofollow">fakeroot-tcp</a></b>(1),
<b><a href="http://linux.die.net/man/1/jigdo-file" rel="nofollow">jigdo-file</a></b>(1),
<b><a href="http://linux.die.net/man/3/librsync" rel="nofollow">librsync</a></b>(3),
<b><a href="http://linux.die.net/man/1/lsyncd" rel="nofollow">lsyncd</a></b>(1),
<b><a href="http://linux.die.net/man/1/nsc" rel="nofollow">nsc</a></b>(1),
<b><a href="http://linux.die.net/man/8/openvas-nvt-sync" rel="nofollow">openvas-nvt-sync</a></b>(8),
<b><a href="http://linux.die.net/man/8/rbldnsd" rel="nofollow">rbldnsd</a></b>(8),
<b><a href="http://linux.die.net/man/1/rdiff-backup" rel="nofollow">rdiff-backup</a></b>(1),
<b><a href="http://linux.die.net/man/1/rsnapshot" rel="nofollow">rsnapshot</a></b>(1),
<b><a href="http://linux.die.net/man/1/rssh" rel="nofollow">rssh</a></b>(1),
<b><a href="http://linux.die.net/man/1/sitecopy" rel="nofollow">sitecopy</a></b>(1)
<div id="adbottom">
<script async="" src="rsync%281%29%20-%20Linux%20man%20page_files/adsbygoogle.js"></script>
<ins data-adsbygoogle-status="done" class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-5823754184406795" data-ad-slot="8789940313"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent"><ins id="aswift_1_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;" frameborder="0" height="280" width="336"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

</li></ul></div>
<div id="menu">
<dl>
<dt>Site Search</dt>
<dd>
<form id="cse-search-box-menu" action="http://www.die.net/search/">
<input name="q" size="10" type="text">
<input name="sa" value="Search" type="hidden">
<input name="ie" value="ISO-8859-1" type="hidden">
<input name="cx" value="partner-pub-5823754184406795:54htp1rtx5u" type="hidden">
<input name="cof" value="FORID:9" type="hidden">
</form>
<script type="text/javascript">
<!--
document.forms["cse-search-box-menu"].action = "http://www.die.net/search/";
// -->
</script>
</dd></dl>



<dl>
<dt>Library</dt>
<dd><a href="http://linux.die.net/">linux docs</a></dd>
<dd><a href="http://linux.die.net/man/">linux man pages</a></dd>
<dd><a href="http://www.die.net/musings/page_load_time/">page load time</a></dd>
</dl>
<dl>
<dt>Toys</dt>
<dd><a href="http://www.die.net/earth/">world sunlight</a></dd>
<dd><a href="http://www.die.net/moon/">moon phase</a></dd>
<dd><a href="http://trace.die.net/">trace explorer</a></dd>
</dl>


<dl>
<dt><a href="http://linux.die.net/man/1/"><img src="rsync%281%29%20-%20Linux%20man%20page_files/back.gif" alt="Back" height="22" width="20"></a></dt><dd></dd>
</dl>
</div></div>
<script type="text/javascript">
<!--
if (top.location != self.location) top.location = self.location;
if (/[?&][pq]=/.test(document.referrer)) document.write(unescape("%3Cscript src='/style/highlight.js' type='text/javascript'%3E%3C/script%3E"));
function googleTranslateElementInit() {new google.translate.TranslateElement({pageLanguage: 'en', floatPosition: google.translate.TranslateElement.FloatPosition.TOP_RIGHT, gaTrack: true, gaId: 'UA-50820-6'});}
if (!/^en/i.test(window.navigator.userLanguage||window.navigator.language)) document.write(unescape("%3Cscript src='//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit' type='text/javascript'%3E%3C/script%3E"));
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
// -->
</script>


</body></html>